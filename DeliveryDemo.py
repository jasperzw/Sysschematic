# Importing tkinter module
from tkinter import *
from matImport import readFile, toAdjecencyMatrixCall, generateGraph
from tkinter.filedialog import askopenfilename
import math
from Scrollwindow import *
from node import removeNodeCall
from noise import addNoiseNodeCall, selectNoiseNodeCall, removeNoiseNodeCall
import numpy as np

"""
initializing all global components
The structure used for both btnStore and outputStore is as follows [windowsId, WidgetObject, x, y]
windowId is the canvas id generated by create_text and widgetObject is the object you can edit to change color and such
the noise store has an extra entry which comes down to [windowsId, WidgetObject, x, y, outputObject] where output Object is the object of the output on which the noise is applied
tempStore follows [widgetId, objectId1, objectId2] object 1 en object 2 is the objects between which the line is connected
widgetId is what you call to remove it from the canvas in draw.delete(widgetId)

lineStore[x][1] and lineStore[x][2] are the modules connected by the line and lineStore[x][3] is the transfer
"""
number_of_nodes = 0
btnStore = []
lineStore = [[]]
lineNumber = 0
outputStore = []
noiseStore = []
connect = []
noiseNumber = 0
outputNumber = 0
excitationStore = []
excitationNumber = 0
noiseNodeNumber = 0
noiseNodeStore = []
storeNG = storeNR = storeNH = []
KnownNodes = []
lineshow = 1;
overlay = 0 #overlay value 0 means the NG matrix and overlay 1 is the Noise overlay
currentAmountOutputSelected = 1 #this variable is so we know the order that outputs are connected. it is not zero because unselected are 0
#global declare is unnecessary since they are declared in the upper script outside any function
#variable which indicates if a click means a module add
clickOperation=0
currentView = 0
butTestStore = []
butTestNumber = 0
knownNodenumber = 0

class nodeHolder():
     nmb = 0

#initializes the main menu. you have to pass the mainmenu frame and the canvas so that it could pass the canvas id when clearing it
def initMainMenu(frame, canvas):

    #column 0
    Button(frame, text="load .mat file", command= lambda: loadMat(draw, master), height = 1, width=20).grid(row=0, padx=2, pady=2)
    Button(frame, text="export .mat file", command= lambda: toAdjecencyMatrix(draw, master), height = 1, width=20).grid(row=1, padx=2, pady=2)
    Button(frame, text="change node view", command= lambda: switchView(draw, master), height = 1, width=20).grid(row=2, padx=2, pady=2)

    #column 1
    Button(frame, text="Options", height = 1, width=20).grid(row=0, column=1, padx=2, pady=2)
    Button(frame, text="Go to global view", height = 1, width=20).grid(row=1, column=1, padx=2, pady=2)
    Button(frame, text="Clear window", command= lambda: clearWindow(canvas,1), height = 1, width=20).grid(row=2, column=1, padx=2, pady=2)

    #column 2
    Button(frame, text="load noise view", command= lambda: plotNoise(draw,master), height = 1, width=20).grid(row=0, column=2, padx=2, pady=2)
    Button(frame, text="load transfer view", command= lambda: plotMatrix(draw,master,0), height = 1, width=20).grid(row=1, column=2, padx=2, pady=2)
    Button(frame, text="change line view", command= lambda: Dashed_line(draw,master), height = 1, width=20).grid(row=2, column=2, padx=2, pady=2)

    #column 3
    OptionMenu(frame, layoutMethod, *layout).grid(row=0, column=3)
#same as main menu initializes the submenu
def initSubMenu(frame):

    #Label(frame, text="currently selected:", bg="gray").pack()
    #Button(frame, text="Add transfer", command= lambda: addWidget(1), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="connect Transfer/module", command= lambda: connectCall(draw,master), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="Remove transfer", command= lambda: removeNode(draw, master),  height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="add node", command= lambda: addWidget(2), height = 1, width=20).pack(padx=2, pady=2)

    #in reload every button or Checkbox is stored which is reloaded on calling reloadCall when currentAmountOutputSelected > 1
    reload = [
    Button(frame, text="remove node", command= lambda: removeOutput(draw, master), height = 1, width=20),
    Button(frame, text="add external excitation", command= lambda: addNHCall(master, draw,0), height = 1, width=20),
    Button(frame, text="remove external excitation", command= lambda: removeNH(draw,master,0), height = 1, width=20),
    Button(frame, text="add noise", command= lambda: addNHCall(master, draw,1), height = 1, width=20),
    Button(frame, text="remove noise", command= lambda: removeNH(master, draw,1), height = 1, width=20),
    Button(frame, text="Make known", command= lambda: Makeknown(master, draw), height = 1, width=20),
    Checkbutton(frame, text="Measurable", height = 1, width=20),
    Checkbutton(frame, text="Unmeasurable", height = 1, width=20),
    Checkbutton(frame, text="Blue", height = 1, width=20),
    Checkbutton(frame, text="Yellow", height = 1, width=20),
    Checkbutton(frame, text="Green", height = 1, width=20),
    ]
    return reload
    #Button(frame, text="Reduction", command= lambda: Reduction(master, draw), height = 1, width=20).pack(padx=2, pady=2)
    #Button(frame, text="remove noise source", command= lambda: removeNoise(), height = 1, width=20).pack(padx=2, pady=2)
    #Button(frame, text="Toggle noise", command= lambda: addWidget(2), height = 1, width=20).pack(padx=2, pady=2)
"""
below are all the functions for

-------------------------------------------------------- Adjecency Matrix --------------------------------------------------------

used to plot adjency matrix and return everything to Adjecency matrix
"""

# Load mat will move everything in from the specific mat file.
def loadMat(draw,master):
    global connect
    global lineNumber
    global lineStore
    global outputStore
    global storeNG
    global storeNR
    global storeNH
    filename = askopenfilename()
    storeNG, storeNR, storeNH = readFile(filename)
    #plotMatrix(draw,master,1)
    abstractPlot(draw,master,storeNG,storeNR,storeNH)

def plotNoise(draw,master):
    global overlay
    global lineNumber
    global lineStore
    global outputStore
    global outputNumber
    global KnownNodes

    if(currentView==0):
        switchView(draw,master)

    NG, NR, NH, KnownNodes= toAdjecencyMatrix(draw,master)
    clearWindow(draw,0)
    overlay = 1


    nmbOutputs = len(NG)
    nmbNoise = len(NH[0])

    pos = generateGraph(NG,NR,NH,1,500*unit.currentZoom, layoutMethod)
    posNoise = generateGraph(NH,NR,NG,1,300*unit.currentZoom, layoutMethod)
    #below function will read through the mat file and try to find how many modules their are
    #plot each function in a circle

    for x in range(nmbOutputs):
        addOutput(draw, pos[x][0], pos[x][1],master)

    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,0)

    for x in range(len(NH[0])):
        addNoiseNode(draw, posNoise[x][0], posNoise[x][1],master)

    for x in range(len(NH)):
        for y in range(len(NH[x])):
            if(NH[x][y]==1):
                node1 = noiseNodeStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)

    #for x in range(len(KnownNodes)):
    #    if(KnownNodes[x]):
    #       for y in range(outputNumber):
    #            if(outputStore[y][1].nmb==x):
    #                selectOutput(outputStore[y][1])
    #                Makeknown(master, draw)


def plotMatrix(draw,master,init):
    global overlay
    global storeNH
    global storeNG
    global storeNR
    global Makeknown
    global outputStore
    global outputNumber

    if(currentView==0):
        switchView(draw,master)
        overlay = 0
        return

    #for init use the stored values else temp save the required values and clear the screen
    if(init):
        NG = storeNG
        NR = storeNR
        NH = storeNH
    else:
        NG, NR, NH, KnownNodes = toAdjecencyMatrix(draw,master)
        clearWindow(draw,0)
        #store noise so that the adjecency function can pick it from global variables
        storeNH = NH
        storeNG = NG
        storeNR = NR

    overlay = 0

    global lineNumber
    global lineStore

    nmbOutputs = len(NG)

    #send the data to networkx to generate positions on the screen
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom,layoutMethod)

    for x in range(nmbOutputs):
        addOutput(draw, pos[x][0], pos[x][1],master)

    #make all the connectiosn tussen connectOutputs
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)

    #for x in range(len(KnownNodes)):
    #    if(KnownNodes[x]):
    #        for y in range(outputNumber):
    #            if(outputStore[y][1].nmb==x):
    #                selectOutput(outputStore[y][1])
    #                Makeknown(master, draw)

    #this is a priority to put the circle and text aboven the lines

    for x in range(len(NH)):
        for y in range(len(NH[x])):
            if(NH[x][y]==1):
                addNH(outputStore[x],master,draw,0,y)

    for x in range(len(NR)):
        for y in range(len(NR[x])):
            if(NR[x][y]==1):
                addNH(outputStore[x],master,draw,1,y)

    draw.tag_raise("nodes")
    draw.tag_raise("rect")
    draw.tag_raise("wNotation")

    #connecting each output is below


def toAdjecencyMatrix(draw,master):
    global storeNG
    global storeNH
    global storeNR
    global butTestStore
    global outputNumber
    global outputStore
    global KnownNodes

    storeNG, storeNR, storeNH, outputNumber, outputStore, KnownNodes= toAdjecencyMatrixCall(draw,master,overlay,storeNG,storeNH,storeNR,lineStore,lineNumber,outputStore,outputNumber,excitationStore,excitationNumber,noiseNodeStore,noiseNodeNumber, KnownNodes)

    return storeNG, storeNR, storeNH, KnownNodes

def abstractPlot(draw,master,NG,NR,NH):
    global butTestStore
    global butTestNumber
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom, layoutMethod)

    nmbOutputs = len(NG)

    #make all the connectiosn tussen connectOutputs
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                draw.create_line(pos[x][0], pos[x][1], pos[y][0], pos[y][1])

    for x in range(nmbOutputs):
        widget = draw.create_circle(pos[x][0], pos[x][1], 5*unit.currentZoom, fill="red")

def switchView(draw, master):
    global storeNG
    global storeNR
    global storeNH
    global currentView
    global overlay

    #switch between abstract view and more complex view speaks for itself.
    if(overlay==0):
        if(currentView == 0):
            currentView = 1
            print("changing to detail")
            draw.delete("all")
            plotMatrix(draw,master,1)

        else:
            if(currentView == 1):
                NG = storeNG
                NR = storeNR
                NH = storeNH
                print("changing to abstract")
                clearWindow(draw,0)
                abstractPlot(draw,master,NG,NR,NH)
                storeNG = NG
                storeNR = NR
                storeNH = NH

                currentView = 0
"""
Below we have the subsection of:

-------------------------------------------------------- nodes --------------------------------------------------------

Each function uses the global variables to store the nodes and to make changes
"""
# adding a node
def addNode(w,x,y,master,node1,node2):
        global number_of_nodes
        global btnStore
        global outputStore
        global outputNumber
        global overlay
        node = 0
        textSize = round(2*unit.currentZoom)
        if(textSize<1):
            textSize = 1

        height = 3*unit.currentZoom
        width = 5*unit.currentZoom

        node_name = "G"
        if(overlay):
            node_name = "H"

        #creating node x
        number_1 = 0
        number_2 = 0
        for a in range(outputNumber):
            if(outputStore[a]==node1):
                number_1 = node1[1].nmb
            if(outputStore[a]==node2):
                number_2 = node2[1].nmb
        for a in range(noiseNodeNumber):
            if(noiseNodeStore[a]==node1):
                number_1 = node1[1].nmb
        #perform initial node
        pixelVirtual = PhotoImage(width=3,height=1)
        if(number_of_nodes==0):
            btn = nodeHolder()
            btn.stat = 1
            btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
            btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
            save = [btn.id,btn,x,y]
            #append it on th end
            btnStore.append(save)
            number_of_nodes = number_of_nodes + 1
            #print("start initial node")

        else:
            #first search if a entry is zero because then a node has been removed their and we can insert a new one
            for m in range(number_of_nodes-1):
                if(btnStore[m]==0):
                    btn = nodeHolder()
                    btn.stat = 1
                    btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                    btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                    save = [btn.id,btn,x,y]
                    btnStore[m] = save
                    #print("added node in existing place")

            #if no space is free and it is not the initial node append a new one on the end.
            if(number_of_nodes!=0 and node == 0):
                btn = nodeHolder()
                btn.stat = 1
                btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                save = [btn.id,btn,x,y]
                btnStore.append(save)
                number_of_nodes = number_of_nodes + 1
                #print("appended node to back of list")

        #print(btnStore)

def removeNode(w, master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber

    number_of_nodes, btnStore, lineStore, lineNumber = removeNodeCall(draw,master,number_of_nodes,btnStore,lineStore,lineNumber)

"""
below are the functions regarding

-------------------------------------------------------- noise and excitation--------------------------------------------------------

important note! these functions are a bit rewritten to allow both external signals and noise manipulations. NorH = 0 is noise and NorH = 1 is excitation. Because if(var) is true if
var = 1 it becomes that if(NorH) is true when we add a excitation signal. We use this to make the below function availible for both signals. first we load in noise because it is most used
and therefor the fastes one and change it if needed for excitation
"""



def addNHCall(master, draw,NorH):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global clickOperation

    if(overlay==0):
        call = popupWindow(master)
        master.wait_window(call.top)
        node = 0
        nmb = call.value
    #find output which is selected and save it to node

        for x in range(outputNumber):
            #print(outputStore[x])
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    addNH(node,master,draw,NorH,nmb)

    else:
        clickOperation=3

def addNH(node,master,draw,NorH,nmb):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global excitationStore
    global excitationNumber
    switch = 0
    width = 8*unit.currentZoom
    heigth = 8*unit.currentZoom
    #print("NorH: ",NorH)
    #move the x y to left above the center of the output
    x,y = trueCoordinates(draw,node)
    marker = nodeHolder()
    textSize = round(2*unit.currentZoom)
    if(textSize<1):
        textSize = 1

    if(NorH==1):
        marker.arc = draw.create_arc(x,y,x+width,y-heigth,fill="yellow")
        marker.text = draw.create_text(x+width*(11/16), y-heigth*(11/16), text="V",width=0, font=("Courier", textSize),tags="wNotation")
    else:
        marker.arc = draw.create_arc(x,y,x-width,y-heigth,fill="green",start=90)
        marker.text = draw.create_text(x-width*(11/16), y-heigth*(11/16), text="R",width=0, font=("Courier", textSize),tags="wNotation")
    marker.stat = 1
    save = [marker.arc,marker,x,y,node[1]]

    #store noise in a open spot
    if(node!=0):
        if(NorH):
            for x in range(excitationNumber):
                if(excitationStore[x]==0 and switch==0):
                    excitationStore.insert(x,save)
                    switch = 1
        else:
            for x in range(noiseNumber):
                if(noiseStore[x]==0 and switch==0):
                    noiseStore.insert(x,save)
                    switch = 1

        #if no open space left append it on the end
        if(switch==0):
            if(NorH):
                excitationStore.append(save)
                excitationNumber = excitationNumber + 1
            else:
                noiseStore.append(save)
                noiseNumber = noiseNumber + 1
            #print("noise or excitation added! number: ",noise)

def removeNH(draw, master, NorH):
    global noiseStore
    global noiseNumber
    global outputStore
    global outputNumber
    global excitationNumber
    global excitationStore

    if(overlay==1):
        removeNoise()
    else:
        node = 0

        #print("trying to remove the noise")

        #find selected output
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    #print("found output: ",node)

        #search for noise entry which has the selected output
        if(NorH):
            for x in range(excitationNumber):
                #print("scanning: ",excitationStore[x])
                if(excitationStore[x]!=0):
                    if(excitationStore[x][4] == node[1]):
                        #print("removing excitation")
                        #remove it
                        draw.delete(excitationStore[x][1].text)
                        draw.delete(excitationStore[x][0])
                        excitationStore[x] = 0
                        if(x == excitationNumber):
                            excitationNumber = excitationNumber - 1
        else:
            for x in range(noiseNumber):
                #print("scanning: ",noiseStore[x])
                if(noiseStore[x]!=0):
                    if(noiseStore[x][4] == node[1]):
                        #print("removing noise")
                        #remove it
                        draw.delete(noiseStore[x][1].text)
                        draw.delete(noiseStore[x][0])
                        noiseStore[x] = 0
                        if(x == noiseNumber):
                            noiseNumber = noiseNumber - 1



"""
Below are the functions for

-------------------------------------------------------- noise Node --------------------------------------------------------

tada
"""

def addNoiseNode(draw,x,y,master):
    global noiseNodeNumber
    global noiseNodeStore

    img1Btn = nodeHolder()
    noiseNodeNumber, noiseNodeStore = addNoiseNodeCall(draw,x,y,master,noiseNodeNumber,noiseNodeStore, img1Btn,unit)

def selectNoiseNode(node):
    global currentAmountOutputSelected

    currentAmountOutputSelected = selectNoiseNodeCall(draw,master,noiseNodeNumber,noiseNodeStore, currentAmountOutputSelected, node,lineNumber,lineStore)

def removeNoise():
    global noiseNodeStore
    global lineStore
    global noiseNodeNumber

    noiseNodeStore, lineStore, noiseNodeNumber = removeNoiseNodeCall(noiseNodeStore, noiseNodeNumber, lineStore, lineNumber, draw)
    removeNode(draw, master)

"""
Below are the functions for

-------------------------------------------------------- output --------------------------------------------------------

tada
"""
def addOutput(draw, x, y, master):
        global outputStore
        global outputNumber
        #create output
        switch = 0
        node = 0
        #set img1btn as object so that we can add .widget containing the circle id.
        img1Btn = nodeHolder()
        img1Btn.widget = draw.create_circle(x,y,5*unit.currentZoom, fill="red", tags="nodes")
        img1Btn.nmb =0
        img1Btn.stat = 1
        img1Btn.zoom = 5*unit.currentZoom
        textSize = round(2*unit.currentZoom)
        img1Btn.nodeMode = []
        if(textSize<1):
            textSize = 1

        for i in range(5):
            img1Btn.nodeMode.append(IntVar())

        #use same save technique so that all the functions remain functional
        save = [img1Btn.widget,img1Btn,x,y]

        #earch if their is a empty entry.
        for m in range(outputNumber):
            if(outputStore[m]==0):
                img1Btn.nmb=m+1
                nmb = draw.create_text(x, y, text="W"+str(m+1),width=0, font=("Courier", textSize),tags="wNotation")
                save.append(nmb)
                outputStore[m] = save
                switch = 1

                #initial output
        if(outputNumber==0):
            img1Btn.nmb=1
            nmb = draw.create_text(x, y, text="W"+str(1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1
            switch = 1

        #append if no empty entry
        if(switch==0):
            img1Btn.nmb=outputNumber+1
            nmb = draw.create_text(x, y, text="W"+str(outputNumber+1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1


def removeOutput(draw,master):
    global outputStore
    global outputNumber
    #search for output and set it to 0
    removeNH(draw,master,0)
    removeNH(draw,master,1)

    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat == 2):
                for i in range(lineNumber):
                    #print("i: ",i," lineStore:",lineStore[i],"")
                    if(lineStore[i]!=0):
                        if(lineStore[i][1]==outputStore[x][1] or lineStore[i][2]==outputStore[x][1]):
                            #print("i: ",i," is deleted")
                            lineStore[i][1].stat == 2
                            draw.delete(lineStore[i][0])
                            removeNode(draw, master)
                            lineStore[i]=0
                draw.delete(outputStore[x][4])
                draw.delete(outputStore[x][0])
                outputStore[x] = 0

def selectOutput(id):
    global currentAmountOutputSelected
    #each output has a stat variable which indicates state. stat == 1 is not selected, stat == 2 is selected
    #work in progress image swap werkt nog niet
    nmb = 0
    #finding corresponding label
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1]==id):
                nmb=outputStore[x][5]


    if(id.stat==1):
        imgGreen = PhotoImage(file="data/outputGreenS.png")
        id.image = imgGreen
        id.stat = 2
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        nmb.configure(bg="limegreen")
        id.configure(image=imgGreen)
        print("setting output green")
        for a in range(lineNumber):
            if (id==lineStore[a][1] or id==lineStore[a][2]):
                draw.itemconfig(lineStore[a][0], fill="red")
    elif(id.stat==2):
        imgWhite = PhotoImage(file="data/outputS.png")
        id.image=imgWhite
        id.stat = 1
        id.order = 0
        currentAmountOutputSelected = currentAmountOutputSelected - 1
        nmb.configure(bg="white")
        id.configure(image=imgWhite)
        print("setting output white")
        for a in range(lineNumber):
            if (id==lineStore[a][1] or id==lineStore[a][2]):
                draw.itemconfig(lineStore[a][0], fill="black")
    elif(id.stat==3):
        imgGreen = PhotoImage(file="data/outputGreenS.png")
        id.image = imgGreen
        id.stat = 4
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        nmb.configure(bg="limegreen")
        id.configure(image=imgGreen)
        print("setting output green")
        for a in range(lineNumber):
            if (id==lineStore[a][1] or id==lineStore[a][2]):
                draw.itemconfig(lineStore[a][0], fill="red")
    elif(id.stat==4):
        imgBlue = PhotoImage(file="data/outputBlueS.png")
        id.image = imgBlue
        id.stat = 3
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        id.configure(image=imgBlue)
        nmb.configure(bg="blue")
        print("setting output Blue")
        for a in range(lineNumber):
            if (id==lineStore[a][1] or id==lineStore[a][2]):
                draw.itemconfig(lineStore[a][0], fill="black")

def Makeknown(master, draw):
    global currentAmountOutputSelected
    global outputStore
    global outputNumber
    global lineStore
    global lineNumber
    global knownNodenumber
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2):
                outputStore[x][1].stat = 4
                selectOutput(outputStore[x][1])
                knownNodenumber +=1
            if(outputStore[x][1].stat==4):
                outputStore[x][1].stat = 2
                selectOutput(outputStore[x][1])
                knownNodenumber -=1

"""
below are the remaining functions

-------------------------------------------------------- Remaining --------------------------------------------------------
"""

def Reduction(master, draw):
    global outputNumber
    global outputStore
    global lineStore
    global lineNumber
    global knownNodenumber
    A1 = []
    L = []
    L11 = []
    L12 = []
    L21 = []
    L22 = []
    NG, NR, NH, KnownNodes= toAdjecencyMatrix(draw,master)
    for x in range(len(NG)):
        A1.append(0)
        for y in range(len(NG)):
            A1[x]=A1[x]+NG[x][y]
    for x in range(len(NG)):
        new = []
        for y in range(len(NG)):
            if(y==x):
                new.append(A1[x])
            else:
                new.append(-NG[x][y])
        L.append(new)
    for x in range(len(NG)-knownNodenumber):
        new = []
        for y in range(len(NG)-knownNodenumber):
            new.append(L[x][y])
        L11.append(new)
    for x in range(knownNodenumber):
        new = []
        for y in range(len(NG)-knownNodenumber):
            new.append(L[len(NG)-knownNodenumber+x][y])
        L12.append(new)
    for x in range(len(NG)-knownNodenumber):
        new = []
        for y in range(knownNodenumber):
            new.append(L[x][len(NG)-knownNodenumber+y])
        L21.append(new)
    for x in range(knownNodenumber):
        new = []
        for y in range(knownNodenumber):
            new.append(L[len(NG)-knownNodenumber+x][len(NG)-knownNodenumber+y])
        L22.append(new)
    L11 = np.array(L11)
    L12 = np.transpose(np.array(L12))
    L21 = np.transpose(np.array(L21))
    L22 = np.linalg.inv(np.array(L22))
    L12_22 = np.dot(L12,L22)
    L12_22_21 = np.dot(L12_22,L21)
    Lhat = np.subtract(L11,L12_22_21)
    A = np.subtract(Lhat,np.diag(Lhat))
    A = np.list(A)
    for x in range(len(A)):
        for y in range(len(A)):
            if(A[x][y]!=0):
                A[x][y]=1
    print(A)


def Dashed_line(draw,master):
    global lineshow
    global lineStore
    global lineNumber
    global overlay

    #only in the noise view dashed lines are existing
    if(overlay):
        if(lineshow):
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "white")
            lineshow = 0
        else:
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "black")
            lineshow = 1

def clearWindow(canvas,canReset):
    #remove everythin and set all global to 0
    global number_of_nodes
    global outputNumber
    global btnStore
    global outputStore
    global noiseStore
    global noiseNumber
    global excitationNumber
    global excitationStore
    global currentAmountOutputSelected
    global lineNumber
    global lineStore
    global noiseNodeStore
    global noiseNodeNumber
    global storeNG
    global storeNR
    global storeNH
    global overlay
    global unit
    global currentView
    canvas.delete("all")
    number_of_nodes = 0
    outputNumber = 0
    btnStore = []
    outputStore = []
    noiseStore = []
    noiseNumber = 0
    excitationStore = []
    excitationNumber = 0
    currentAmountOutputSelected = 0
    linestore = 0
    lineNumber = 0
    noiseNodeNumber = 0
    noiseNodeStore = []
    storeNG = storeNR = storeNH = []
    overlay = 0
    currentview = 0
    if(canReset==1):
        if(unit.currentZoom > 1):
            unit.canvas.scale('all', unit.currentZoom, unit.currentZoom, 1, 1)
        if(unit.currentZoom < 1):
            unit.canvas.scale('all', 1, 1, unit.currentZoom, unit.currentZoom)
        unit.currentZoom = 1



#Deze functie word aangeroepen van uit het menu en haalt dan 2 nodes er uit die hij door geeft aan connectoutput
def connectCall(draw,master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    node1 = 0
    node2 = 0

    #serach first for selected outputs
    for x in range(outputNumber):
        if(outputStore[x][1].stat==2):
            if(outputStore[x][1]!=node1 and node1==0):
                node1 = outputStore[x]
            elif(node2!=outputStore[x][1]):
                node2 = outputStore[x]

    if(overlay==1):
        node2 = 0
        for x in range(noiseNodeNumber):
            if(noiseNodeStore[x][1].stat==2):
                if(noiseNodeStore[x][1]!=node2 and node2==0):
                    node2 = noiseNodeStore[x]
                    #print("found noise at: ",node2," linking to ",node1)


    #check if the node is not the same or not 0.
    if((node1==node2) or (node1 == 0 or node2 == 0)):
        print("error occured with node selection")

    else:
        #check for which order they are selected so that the last selected is the target module and the first the origin.
        if(node1[1].order > node2[1].order):
            connectOutputs(node2,node1,draw,master,1)
        else:
            connectOutputs(node1,node2,draw,master,1)
        xObj, yObj = trueCoordinates(draw,node1)
        circleScan(draw,master,xObj,yObj)
        if(overlay==0):
            xObj, yObj = trueCoordinates(draw,node2)
            circleScan(draw,master,xObj,yObj)
        else:
            selectNoiseNode(node2[1])

#connect outputs is nu 2 functies zodat je via plotmatrix ook connectOutputs direct kan aangroepen
def connectOutputs(node1,node2,draw,master, placeBtn):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    temp = 0
    node3 = 0


    for x in range(lineNumber):
        if(lineStore[x]!=0):
            if(node1[1]==lineStore[x][1] and node2[1]==lineStore[x][2]):
                temp = 1
    if(node1==node2):
        temp = 1
    #make sure that the connection is not made already or the nodes are the same
    #else make the connection
    if(temp==0):
        node1[2],node1[3] = trueCoordinates(draw,node1)
        node2[2],node2[3] = trueCoordinates(draw,node2)
        x_middle = (node2[2] + node1[2])/2
        y_middle = (node1[3] + node2[3])/2

        #draw the curve

        if((node2[2]-node1[2])!=0):
            theta = math.degrees(math.atan((node2[3]-node1[3])/(node2[2]-node1[2])))
        else:
            theta = 90;
        length_line = math.sqrt(math.pow(node2[2]-node1[2],2)+math.pow(node2[3]-node1[3],2))/2
        height_curve = length_line/3
        if(node1>node2):
            x_transfer = x_middle + math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle - math.sin(math.radians(90-theta))*height_curve
        else:
            x_transfer = x_middle - math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle + math.sin(math.radians(90-theta))*height_curve
        #draw the transfer
        #set btn when needed.
        if(placeBtn):
            addNode(draw,(x_transfer+x_middle)/2,(y_transfer+y_middle)/2,master,node1,node2)
            for x in range(number_of_nodes):
                if(btnStore[x]!=0):
                    if(btnStore[x][2]==(x_transfer+x_middle)/2 and btnStore[x][3]==(y_transfer+y_middle)/2):
                        node3 = btnStore[x]
        else:
            #create a fake note
            node3 = [1,1]
        #end of draw the tranfer

        if(placeBtn):
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true")
        else:
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true", width=0.01, dash=(5, 10))
        tempStore = [lineWidget, node1[1], node2[1], node3[1]]
        lineStore.insert(lineNumber,tempStore)
        lineNumber = lineNumber+1


        #draw the arrow

        gamma = 45/2 #adjust the angle of the arrow
        length_arrow = 5 #adjust the lenght of the arrow

        sign_2 = 1
        if(node1[2]>node2[2]):
            sign_2 = -1
        epsilon = 180-gamma-theta-height_curve/20-90
        if(node1>node2):
            x_arrow0 = (x_middle+node2[2])/2 + math.cos(math.radians(90-theta))*height_curve/5*2
            y_arrow0 = (y_middle+node2[3])/2 - math.sin(math.radians(90-theta))*height_curve/5*2
        else:
            x_arrow0 = (x_middle+node2[2])/2 - math.cos(math.radians(90-theta))*height_curve/5*2
            y_arrow0 = (y_middle+node2[3])/2 + math.sin(math.radians(90-theta))*height_curve/5*2
        x_arrow1 = x_arrow0 - sign_2*math.sin(math.radians(epsilon))*length_arrow
        y_arrow1 = y_arrow0 - sign_2*math.cos(math.radians(epsilon))*length_arrow
        alpha = gamma+epsilon
        alpha_hypotenusa = sign_2*math.sin(math.radians(gamma))*length_arrow*2
        x_arrow2 = x_arrow1 - math.cos(math.radians(alpha))*alpha_hypotenusa
        y_arrow2 = y_arrow1 + math.sin(math.radians(alpha))*alpha_hypotenusa
        tempStore2 = [draw.create_line(x_arrow1, y_arrow1, x_arrow0,y_arrow0, x_arrow2, y_arrow2),node1[1],node2[1],node3[1]]
        lineStore.insert(lineNumber,tempStore2)
        lineNumber = lineNumber+1

        draw.tag_raise("nodes")
        draw.tag_raise("rect")
        draw.tag_raise("wNotation")

def addWidget(input):
    #set the clickOperation variable
    global clickOperation
    clickOperation = input


def clickEvent(event):
    #on button press perform an action based on click clickOperation
    global clickOperation
    x = draw.canvasx(event.x)
    y = draw.canvasy(event.y)
    if(clickOperation==0 and currentView == 1):
        circleScan(draw,master,x,y)
    if(clickOperation==1):
        addNode(event.widget, x, y, master)
        clickOperation=0

    if(clickOperation==2):
        addOutput(event.widget, x, y, master)
        print("node added at: ",x,",",y)
        clickOperation=0

    if(clickOperation==3):
        addNoiseNode(draw, x, y, master)
        clickOperation=0

def circleScan(draw,master,x,y):
    global currentAmountOutputSelected
    #this function scans the mouse click and tries to find if it is within a circle
    print("scanning for button at: ",x,",",y)
    #draw.create_circle(x,y,10,fill="green")
    #circle through all known nodes to check within their radius
    for f in range(outputNumber):
        if(outputStore[f]!=0):
            #the zoom function and drag messes with the old coordintes with trueCoordinates you obtain the in that view correct coordinates
            xObj, yObj = trueCoordinates(draw,outputStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < 5*unit.currentZoom):
                id = outputStore[f][1]
                if(outputStore[f][1].stat==1):
                    print("circle selected at: ",xObj,",",yObj)
                    id.order = currentAmountOutputSelected
                    currentAmountOutputSelected = currentAmountOutputSelected + 1
                    outputStore[f][1].stat = 2
                    draw.itemconfig(outputStore[f][0],fill="blue")
                    #print("buttond found!")
                    for a in range(lineNumber):
                        if(lineStore[a]!=0):
                            if (id==lineStore[a][1] or id==lineStore[a][2]):
                                draw.itemconfig(lineStore[a][0], fill="red")
                else:
                    id.order = 0
                    currentAmountOutputSelected = currentAmountOutputSelected - 1
                    outputStore[f][1].stat = 1
                    draw.itemconfig(outputStore[f][0],fill="red")
                    print("buttond found!")
                    for a in range(lineNumber):
                        if(lineStore[a]!=0):
                            if (id==lineStore[a][1] or id==lineStore[a][2]):
                                draw.itemconfig(lineStore[a][0], fill="black")

    for f in range(noiseNodeNumber):
        if(noiseNodeStore[f]!=0):
            xObj, yObj = trueCoordinates(draw,noiseNodeStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < 5*unit.currentZoom):
                id = noiseNodeStore[f]
                selectNoiseNode(id)

    for f in range(number_of_nodes):
        if(btnStore[f]!=0):
            if(btnStore[f]!=0):
                xObj, yObj = trueCoordinates(draw,btnStore[f])
                yObj -= 2*unit.currentZoom
                height = 3*unit.currentZoom
                width = 5*unit.currentZoom
                #print("searching for x: ",xObj," y: ",yObj)
                #print(x,",",y)
                if(xObj-width<x and x<xObj+width):
                    if(yObj-height<y and y<yObj+height):
                        if(btnStore[f][1].stat==1):
                            draw.itemconfig(btnStore[f][0], fill="yellow")
                            btnStore[f][1].stat=2
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="red")

                        else:
                            draw.itemconfig(btnStore[f][0], fill="cyan")
                            btnStore[f][1].stat=1
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="black")
    #reload the right view if a node is selected
    selectedNode = 0
    if(currentAmountOutputSelected == 2):
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat==2):
                    selectedNode=outputStore[x][1]
                    print("found node and giving it to reloadCall")
    reloadCall(subMenu,reload,currentAmountOutputSelected,selectedNode)




def trueCoordinates(draw,node):
    #draw.coords obtains the current coordinates based on the widget id. + the radius multiply by zoom to shift the left corner of the widget to the center.
    xObj = draw.coords(node[0])[0]+5*unit.currentZoom
    yObj = draw.coords(node[0])[1]+5*unit.currentZoom
    #xObj = draw.canvasx(node[2])
    #yObj = draw.canvasy(node[3])
    return xObj, yObj

""""
    Zoom_buttons(unit.imscale)

def Zoom_buttons(scale):
    global scale_prev
    global number_of_nodes
    global btnStore
    if(scale_prev!=scale):
        scale_prev = scale
        for x in range(number_of_nodes):
            if(btnStore[x]!=0):
                btnStore[x][1].configure(height=int(scale*10),width=int(scale*30))
                btnStore[x][1].pack()
"""

"""
Below you will find the basic setup of the grid

-------------------------------------------------------- Grid interface setup and initialization --------------------------------------------------------
"""

# creating Tk window
master = Tk()
master.configure(background="gray")
master.title("Delivery Demo")
#set initial size
master.geometry("1500x1500")

#create a grid which can reize with the resizing of the box
Grid.rowconfigure(master, 0, weight=1)
Grid.columnconfigure(master, 0, weight=1)
masterFrame = Frame(master)
masterFrame.grid(row=0, column=0, sticky=N+S+E+W)
Grid.rowconfigure(masterFrame, 0, weight=1)
Grid.rowconfigure(masterFrame, 1, weight=100)
Grid.columnconfigure(masterFrame, 0, weight=100)
Grid.columnconfigure(masterFrame, 1, weight=1)

#seperating the menu in different frames which will hold all the components so that it is easier to use .grid for button placemant
#main menu is for the upper buttons, canvas is for draw, subMenu is for the component selection
mainMenu = Frame(masterFrame, bg="gray")
canvas = Frame(masterFrame, bg="white")
subMenu = Frame(masterFrame, bg="gray")

#set each frame in the grid
mainMenu.grid(row=0,sticky=N+S+E+W)
canvas.grid(row=1, sticky=N+S+E+W)
subMenu.grid(row=0, column=1, rowspan=2, sticky=N+S+E+W)

#create a canvas called draw in the canvas frame
draw = Canvas(canvas, bg="white")
draw.pack(fill="both", expand=True)

layout = [
"circular",
"kamada_kawai",
"spring",
"spectral",
"spiral"
]

layoutMethod = StringVar(master)
layoutMethod.set(layout[1])

#bind functions to events
initMainMenu(mainMenu, draw)
reload = initSubMenu(subMenu)

#set the draw canvas with the scroll and pan option
unit = Zoom_Advanced(draw)
#bind button Release to the clickevent
unit.canvas.bind("<ButtonRelease-1>",clickEvent)
mainloop()
