# Importing tkinter module
from tkinter import *
from matImport import readFile, toAdjacencyMatrixCall, generateGraph, graphShortestPath
from tkinter.filedialog import askopenfilename
import math
from Scrollwindow import *
from node import removeNodeCall
from noise import addNoiseNodeCall, selectNoiseNodeCall, removeNoiseNodeCall
#from matlabCaller import test_identifiability_caller
import numpy as np
import networkx as nx
import copy
import random


"""
initializing all global components
The structure used for both btnStore and outputStore is as follows [windowsId, WidgetObject, x, y]
windowId is the canvas id generated by create_text and widgetObject is the object you can edit to change color and such
the noise store has an extra entry which comes down to [windowsId, WidgetObject, x, y, outputObject] where output Object is the object of the output on which the noise is applied
tempStore follows [widgetId, objectId1, objectId2] object 1 en object 2 is the objects between which the line is connected
widgetId is what you call to remove it from the canvas in draw.delete(widgetId)

lineStore[x][1] and lineStore[x][2] are the modules connected by the line and lineStore[x][3] is the transfer
"""
number_of_nodes = 0
btnStore = []
lineStore = [[]]
lineNumber = 0
outputStore = []
noiseStore = []
connect = []
noiseNumber = 0
outputNumber = 0
excitationStore = []
excitationNumber = 0
noiseNodeNumber = 0
noiseNodeStore = []
nodeSize = 5
storeNG = storeNR = storeNH = []
NG_pms = NR_pms = NH_pms = []
Unknownnodes = []
lineshow = 1;
overlay = 0 #overlay value 0 means the NG matrix and overlay 1 is the Noise overlay
currentAmountOutputSelected = 1 #this variable is so we know the order that outputs are connected. it is not zero because unselected are 0
#global declare is unnecessary since they are declared in the upper script outside any function
#variable which indicates if a click means a module add
clickOperation=0
currentView = 0
butTestStore = []
butTestNumber = 0
unknownNodenumber = 0
newPathColor = 0

class nodeHolder():
     nmb = 0

#initializes the main menu. you have to pass the mainmenu frame and the canvas so that it could pass the canvas id when clearing it
def initMainMenu(frame, canvas):

    #column 0
    Button(frame, text="load .mat file", command= lambda: loadMat(draw, master), height = 1, width=20).grid(row=0, padx=2, pady=2)
    Button(frame, text="export .mat file", command= lambda: toAdjacencyMatrix(draw, master), height = 1, width=20).grid(row=1, padx=2, pady=2)
    Button(frame, text="change node view", command= lambda: switchView(draw, master), height = 1, width=20).grid(row=2, padx=2, pady=2)

    #column 1
    Button(frame, text="Options", height = 1, width=20).grid(row=0, column=1, padx=2, pady=2)
    Button(frame, text="Go to global view", height = 1, width=20).grid(row=1, column=1, padx=2, pady=2)
    Button(frame, text="Clear window", command= lambda: clearWindow(canvas,1), height = 1, width=20).grid(row=2, column=1, padx=2, pady=2)

    #column 2
    Button(frame, text="load noise view", command= lambda: plotNoise(draw,master), height = 1, width=20).grid(row=0, column=2, padx=2, pady=2)
    Button(frame, text="load transfer view", command= lambda: plotMatrix(draw,master,0), height = 1, width=20).grid(row=1, column=2, padx=2, pady=2)
    Button(frame, text="change line view", command= lambda: Dashed_line(draw,master), height = 1, width=20).grid(row=2, column=2, padx=2, pady=2)
    #column 3
    Button(frame, text="MIC", command= lambda: MIC(master, draw), height = 1, width=20).grid(row=1, column=3, padx=2, pady=2)


    #column 3
    OptionMenu(frame, layoutMethod, *layout).grid(row=0, column=3)
#same as main menu initializes the submenu
def initSubMenu(frame):

    #Label(frame, text="currently selected:", bg="gray").pack()
    #Button(frame, text="Add transfer", command= lambda: addWidget(1), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="connect Transfer/module", command= lambda: connectCall(draw,master), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="Remove transfer", command= lambda: removeNode(draw, master),  height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="add output", command= lambda: addWidget(2), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="toggle transfer known", command= lambda: toggleTransfer(master, draw), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="toggle transfer pms", command= lambda: PMSTransfer(master, draw), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="Perform test identifiability", command= lambda: testIdentifiability(master, draw), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="Find shortest path", command= lambda: find_path(draw,master), height = 1, width=20).pack(padx=2, pady=2)
    Button(frame, text="Immersion", command= lambda: Immersion_call(master, draw), height = 1, width=20).pack(padx=2, pady=2)
    #in reload every button or Checkbox is stored which is reloaded on calling reloadCall when currentAmountOutputSelected > 1
    reload = [
    Button(frame, text="remove node", command= lambda: removeOutput(draw, master), height = 1, width=20),
    Button(frame, text="add external excitation", command= lambda: addNHCall(master, draw,0), height = 1, width=20),
    Button(frame, text="remove external excitation", command= lambda: removeNH(draw,master,0), height = 1, width=20),
    Button(frame, text="add noise", command= lambda: addNHCall(master, draw,1), height = 1, width=20),
    Button(frame, text="remove noise", command= lambda: removeNH(master, draw,1), height = 1, width=20),
    Button(frame, text="Make unknown", command= lambda: makeunkown(master, draw), height = 1, width=20),
    Checkbutton(frame, text="excitation measurable", height = 1, width=20),
    Checkbutton(frame, text="noise measurable", height = 1, width=20),
    Checkbutton(frame, text="Blue", height = 1, width=20),
    Checkbutton(frame, text="Yellow", height = 1, width=20),
    Checkbutton(frame, text="Green", height = 1, width=20),
    ]
    return reload

    #Button(frame, text="remove noise source", command= lambda: removeNoise(), height = 1, width=20).pack(padx=2, pady=2)
    #Button(frame, text="Toggle noise", command= lambda: addWidget(2), height = 1, width=20).pack(padx=2, pady=2)
"""
below are all the functions for

-------------------------------------------------------- Adjacency Matrix --------------------------------------------------------

used to plot adjency matrix and return everything to Adjacency matrix
"""

def toggleTransfer(master,draw):
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].stat==2):
                if(btnStore[x][1].known==0):
                    btnStore[x][1].known = 1
                else:
                    btnStore[x][1].known = 0
                x, y = trueCoordinates(draw,btnStore[x])
                circleScan(draw,master,x,y)

def PMSTransfer(master,draw):
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].stat==2):
                if(btnStore[x][1].pms==0):
                    btnStore[x][1].pms = 1
                else:
                    btnStore[x][1].pms = 0
                x, y = trueCoordinates(draw,btnStore[x])
                circleScan(draw,master,x,y)

def testIdentifiability(master,draw):
    NG = []
    NR = []
    NH = []
    KnownNodes = []
    #set everything first to zero
    print("test: ",noiseNumber)
    for x in range(outputNumber):
        new = []
        for y in range(outputNumber):
            new.append(0)
        NG.append(new)
        new = []
        if(noiseNumber!=0):
            for y in range(noiseNumber):
                new.append(0)
        NH.append(new)
        new = []
        if(excitationNumber!=0):
            for y in range(excitationNumber):
                new.append(0)
        NR.append(new)
        KnownNodes.append(0)

    #run the above functions to generate a corresponding NG NR and NH matrix which we then fill with the measurable signals

    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].known==1):
                NG[btnStore[x][5]-1][btnStore[x][4]-1] = 1


    #set kown transfer to measurable in NG matrix
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            print("nodeMode: ", outputStore[x][1].nodeMode[0].get() ," found at: ", outputStore[x][0])
            if(outputStore[x][1].nodeMode[0].get()==1):
                #for y in range(excitationNumber):
                    #if(excitationStore[y][4]==outputStore[x][1]):
                        #NR[x][excitationStore[y][1].nmb-1]=1
                        NR[x][x] = 1
                        print("set excitation to high")
            if(outputStore[x][1].nodeMode[1].get()==1):
                for y in range(noiseNumber):
                    if(noiseStore[y][4]==outputStore[x][1]):
                        NH[x][noiseStore[y][1].nmb-1]=1
                        print("set noise to high")

    #check each node if they have the nosie or excitation measurable selected and the note that in the NH and NR matrix

    adjG, adjR, adjH, unkown = toAdjacencyMatrix(draw,master)

    replaceH = []
    for x in range(len(adjH)):
        new = []
        for y in range(len(adjH[0])):
            new.append(adjH[x][y])
        replaceH.append(new)


    #this function is simpely their because the NH matrix is not changed from when it was imported and needs to go in a different format which matlab can interpret
    adjH = replaceH

    #call the test_identifiability_caller to transfer everything to matlab


    print("NG matrix: ",NG)
    print("--------------------------------------------------------------------------------------")
    print("NR matrix: ",NR)
    print("--------------------------------------------------------------------------------------")
    print("NH matrix: ",NH)
    print("//////////////////////////////////////////////////////////////////////////////////////")

    identifiability, identifiability_nodes, identifiability_modules = test_identifiability_caller(adjG,adjR,adjH,NG,NR,NH)

    print("found the following")
    print("NG matrix: ",identifiability)
    print("--------------------------------------------------------------------------------------")
    print("NR matrix: ",identifiability_nodes)
    print("--------------------------------------------------------------------------------------")
    print("NH matrix: ",identifiability_modules)
    for x in range(len(identifiability_modules)):
        for y in range(len(identifiability_modules[0])):
            if(identifiability_modules[x][y]==1):
                nodefrom = y + 1
                nodeto = x + 1
                #check which transfer is measurable
                #print("module is 1 and trying to set the number of nodes for From: ",nodefrom," To: ",nodeto)
                for f in range(number_of_nodes):
                    if(btnStore[f]!=0):
                        if(btnStore[f][4]==nodeto and btnStore[f][5]==nodefrom):
                            #check which btn it is corresonding to
                            #print("setting tranfer to known after identifiability check")
                            draw.itemconfig(btnStore[f][0],fill="green")
                            btnStore[f][1].known = 1
                            #set the transfer to known


# Load mat will move everything in from the specific mat file.
def loadMat(draw,master):
    global connect
    global lineNumber
    global lineStore
    global outputStore
    global storeNG
    global storeNR
    global storeNH
    global nodeSize
    filename = askopenfilename()
    storeNG, storeNR, storeNH = readFile(filename)
    #plotMatrix(draw,master,1)
    abstractPlot(draw,master,storeNG,storeNR,storeNH)
    nodeSize = -(10/110)*(len(storeNG)**1.8)+26
    if(nodeSize<5):
        nodeSize=5

def plotNoise(draw,master):
    global overlay
    global lineNumber
    global lineStore
    global outputStore
    global outputNumber
    global Unknownnodes
    global excitationNumber
    global storeNG
    global storeNH
    global storeNR

    if(currentView==0):
        switchView(draw,master)
    NG, NR, NH, Unknownnodes = toAdjacencyMatrix(draw,master)

    clearWindow(draw,0)
    overlay = 1

    amountNodes = len(NG)
    nmbNoise = len(NH[0])
    excitationNumber = len(NR)

    pos = generateGraph(NG,NR,NH,1,500*unit.currentZoom, layoutMethod)
    plotNoise = nx.DiGraph()
    plotNoise.add_nodes_from(pos.keys())
    for n in range(amountNodes):
        plotNoise.nodes[n]['pos'] = pos[n]

    nmbOutputs = len(NH)
    nmbOutputs2 = len(NH[0])
    #print("nmbOutputs: ",nmbOutputs," nmbOutputs2: ",nmbOutputs2)
    plotNoise.add_nodes_from(range(amountNodes,amountNodes+nmbOutputs))
    for x in range(nmbOutputs):
        for y in range(len(NH[x])):
            if(NH[x][y] == 1):
                #print("added edge from y: ",y+amountNodes," to x: ",x, " for: ", NH[x][y])
                plotNoise.add_edge(y+amountNodes,x)
    posNoise = nx.spring_layout(plotNoise, scale=500*unit.currentZoom, center=(500,500))
    print(posNoise)


    #below function will read through the mat file and try to find how many modules their are
    #plot each function in a circle

    for x in range(amountNodes):
        addOutput(draw, pos[x][0], pos[x][1],master)

    for x in range(amountNodes):
        for y in range(amountNodes):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,0)


    for x in range(nmbOutputs2):
        addNoiseNode(draw, posNoise[x+amountNodes][0], posNoise[x+amountNodes][1],master)

    for x in range(nmbOutputs):
        for y in range(nmbOutputs2):
            if(NH[x][y]==1):
                node1 = noiseNodeStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)
    #for x in range(len(Unknownnodes)):
    #    if(Unknownnodes[x]):
    #       for y in range(outputNumber):
    #            if(outputStore[y][1].nmb==x):
    #                selectOutput(outputStore[y][1])
    #                makeunkown(master, draw)
    storeNR = NR
    storeNH = NH
    storeNG = NG

def plotMatrix(draw,master,init):
    global overlay
    global storeNH
    global storeNG
    global storeNR
    global Makeknown
    global outputStore
    global outputNumber
    global excitationNumber

    if(currentView==0):
        switchView(draw,master)
        overlay = 0
        return

    #for init use the stored values else temp save the required values and clear the screen
    if(init):
        NG = storeNG
        NR = storeNR
        NH = storeNH
    else:
        NG, NR, NH, Unknownnodes = toAdjacencyMatrix(draw,master)
        clearWindow(draw,0)
        excitationNumber = 0
        #store noise so that the Adjacency function can pick it from global variables
        storeNH = NH
        storeNG = NG
        storeNR = NR

    overlay = 0

    global lineNumber
    global lineStore

    nmbOutputs = len(NG)

    #send the data to networkx to generate positions on the screen
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom,layoutMethod)

    for x in range(nmbOutputs):
        addOutput(draw, pos[x][0], pos[x][1],master)

    #make all the connectiosn tussen connectOutputs
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)

    #for x in range(len(Unknownnodes)):
    #    if(Unknownnodes[x]):
    #        for y in range(outputNumber):
    #            if(outputStore[y][1].nmb==x):
    #                selectOutput(outputStore[y][1])
    #                makeunkown(master, draw)

    #this is a priority to put the circle and text aboven the lines

    for x in range(len(NH)):
        for y in range(len(NH[x])):
            if(NH[x][y]==1):
                addNH(outputStore[x],master,draw,0,y)
    for x in range(len(NR)):
        for y in range(len(NR[x])):
            if(NR[x][y]==1):
                addNH(outputStore[x],master,draw,1,y)

    draw.tag_raise("nodes")
    draw.tag_raise("rect")
    draw.tag_raise("wNotation")

    #connecting each output is below


def toAdjacencyMatrix(draw,master):
    global storeNG
    global storeNH
    global storeNR
    global butTestStore
    global outputNumber
    global outputStore
    global Unknownnodes
    print(storeNR)
    storeNG, storeNR, storeNH, outputNumber, outputStore, Unknownnodes= toAdjacencyMatrixCall(draw,master,overlay,storeNG,storeNH,storeNR,lineStore,lineNumber,outputStore,outputNumber,excitationStore,excitationNumber,noiseNodeStore,noiseNodeNumber, Unknownnodes)

    return storeNG, storeNR, storeNH, Unknownnodes

def abstractPlot(draw,master,NG,NR,NH):
    global butTestStore
    global butTestNumber
    #generate the positions
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom, layoutMethod)
    nmbOutputs = len(NG)

    #make all the connectiosn tussen connectOutputs
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                #first draw the lines
                draw.create_line(pos[x][0], pos[x][1], pos[y][0], pos[y][1])

    for x in range(nmbOutputs):
        #draw each node
        widget = draw.create_circle(pos[x][0], pos[x][1], 5*unit.currentZoom, fill="red")

def switchView(draw, master):
    global storeNG
    global storeNR
    global storeNH
    global currentView
    global overlay

    #switch between abstract view and more complex view speaks for itself.
    if(overlay==0):
        if(currentView == 0):
            currentView = 1
            print("changing to detail")
            draw.delete("all")
            plotMatrix(draw,master,1)

        else:
            if(currentView == 1):
                NG = storeNG
                NR = storeNR
                NH = storeNH
                print("changing to abstract")
                clearWindow(draw,0)
                abstractPlot(draw,master,NG,NR,NH)
                storeNG = NG
                storeNR = NR
                storeNH = NH

                currentView = 0
"""
Below we have the subsection of:

-------------------------------------------------------- nodes --------------------------------------------------------

Each function uses the global variables to store the nodes and to make changes
"""
# adding a node

def toggleTransfer(master,draw):
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].stat==2):
                if(btnStore[x][1].known==0):
                    btnStore[x][1].known = 1
                else:
                    btnStore[x][1].known = 1
                x, y = trueCoordinates(draw,btnStore[x])
                circleScan(draw,master,x,y)

def addNode(w,x,y,master,node1,node2):
        global number_of_nodes
        global btnStore
        global outputStore
        global outputNumber
        global overlay
        node = 0
        textSize = round(nodeSize/2*unit.currentZoom)
        if(textSize<1):
            textSize = 1

        height = nodeSize*unit.currentZoom*0.8
        width = nodeSize*unit.currentZoom

        node_name = "G"
        if(overlay):
            node_name = "H"

        #creating node x
        number_1 = 0
        number_2 = 0
        for a in range(outputNumber):
            if(outputStore[a]==node1):
                number_1 = node1[1].nmb
            if(outputStore[a]==node2):
                number_2 = node2[1].nmb
        for a in range(noiseNodeNumber):
            if(noiseNodeStore[a]==node1):
                number_1 = node1[1].nmb
        #perform initial node
        pixelVirtual = PhotoImage(width=3,height=1)
        if(number_of_nodes==0):
            btn = nodeHolder()
            btn.stat = 1
            btn.known = 0
            btn.pms = 0
            btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
            btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
            save = [btn.id,btn,x,y,number_1,number_2]
            #append it on th end
            btnStore.append(save)
            number_of_nodes = number_of_nodes + 1
            #print("start initial node")

        else:
            #first search if a entry is zero because then a node has been removed their and we can insert a new one
            for m in range(number_of_nodes-1):
                if(btnStore[m]==0):
                    btn = nodeHolder()
                    btn.stat = 1
                    btn.known = 0
                    btn.pms = 0
                    btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                    btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                    save = [btn.id,btn,x,y,number_1,number_2]
                    btnStore[m] = save
                    #print("added node in existing place")

            #if no space is free and it is not the initial node append a new one on the end.
            if(number_of_nodes!=0 and node == 0):
                btn = nodeHolder()
                btn.stat = 1
                btn.known = 0
                btn.pms = 0
                btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                save = [btn.id,btn,x,y,number_1,number_2]
                btnStore.append(save)
                number_of_nodes = number_of_nodes + 1
                #print("appended node to back of list")

        #print(btnStore)

def removeNode(w, master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber

    number_of_nodes, btnStore, lineStore, lineNumber = removeNodeCall(draw,master,number_of_nodes,btnStore,lineStore,lineNumber)

"""
below are the functions regarding

-------------------------------------------------------- noise and excitation--------------------------------------------------------

important note! these functions are a bit rewritten to allow both external signals and noise manipulations. NorH = 0 is noise and NorH = 1 is excitation. Because if(var) is true if
var = 1 it becomes that if(NorH) is true when we add a excitation signal. We use this to make the below function availible for both signals. first we load in noise because it is most used
and therefor the fastes one and change it if needed for excitation
"""



def addNHCall(master, draw,NorH):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global clickOperation

    if(overlay==0):
        call = popupWindow(master)
        master.wait_window(call.top)
        node = 0
        nmb = call.value
    #find output which is selected and save it to node

        for x in range(outputNumber):
            #print(outputStore[x])
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    addNH(node,master,draw,NorH,nmb)

    else:
        clickOperation=3

def addNH(node,master,draw,NorH,nmb):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global excitationStore
    global excitationNumber
    switch = 0
    width = nodeSize*unit.currentZoom*1.6
    heigth = nodeSize*unit.currentZoom*1.6
    #print("NorH: ",NorH)
    #move the x y to left above the center of the output
    x,y = trueCoordinates(draw,node)
    marker = nodeHolder()
    marker.nmb = nmb
    textSize = round(nodeSize/2*unit.currentZoom)
    if(textSize<1):
        textSize = 1

    if(NorH==1):
        marker.arc = draw.create_arc(x,y,x+width,y-heigth,fill="yellow")
        marker.text = draw.create_text(x+width*(11/16), y-heigth*(11/16), text="V",width=0, font=("Courier", textSize),tags="wNotation")
    else:
        marker.arc = draw.create_arc(x,y,x-width,y-heigth,fill="green",start=90)
        marker.text = draw.create_text(x-width*(11/16), y-heigth*(11/16), text="R",width=0, font=("Courier", textSize),tags="wNotation")
    marker.stat = 1
    save = [marker.arc,marker,x,y,node[1]]

    #store noise in a open spot
    if(node!=0):
        if(NorH):
            for x in range(excitationNumber):
                if(excitationStore[x]==0 and switch==0):
                    excitationStore.insert(x,save)
                    switch = 1
        else:
            for x in range(noiseNumber):
                if(noiseStore[x]==0 and switch==0):
                    noiseStore.insert(x,save)
                    switch = 1

        #if no open space left append it on the end
        if(switch==0):
            if(NorH):
                excitationStore.append(save)
                excitationNumber = excitationNumber + 1
            else:
                noiseStore.append(save)
                noiseNumber = noiseNumber + 1
            #print("noise or excitation added! number: ",noise)

def removeNH(draw, master, NorH):
    global noiseStore
    global noiseNumber
    global outputStore
    global outputNumber
    global excitationNumber
    global excitationStore

    if(overlay==1):
        removeNoise()
    else:
        node = 0

        #print("trying to remove the noise")

        #find selected output
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    #print("found output: ",node)

        #search for noise entry which has the selected output
        if(NorH):
            for x in range(excitationNumber):
                #print("scanning: ",excitationStore[x])
                if(excitationStore[x]!=0):
                    if(excitationStore[x][4] == node[1]):
                        #print("removing excitation")
                        #remove it
                        draw.delete(excitationStore[x][1].text)
                        draw.delete(excitationStore[x][0])
                        excitationStore[x] = 0
                        if(x == excitationNumber):
                            excitationNumber = excitationNumber - 1
        else:
            for x in range(noiseNumber):
                #print("scanning: ",noiseStore[x])
                if(noiseStore[x]!=0):
                    if(noiseStore[x][4] == node[1]):
                        #print("removing noise")
                        #remove it
                        draw.delete(noiseStore[x][1].text)
                        draw.delete(noiseStore[x][0])
                        noiseStore[x] = 0
                        if(x == noiseNumber):
                            noiseNumber = noiseNumber - 1



"""
Below are the functions for

-------------------------------------------------------- noise Node --------------------------------------------------------

tada
"""

def addNoiseNode(draw,x,y,master):
    global noiseNodeNumber
    global noiseNodeStore

    img1Btn = nodeHolder()
    noiseNodeNumber, noiseNodeStore = addNoiseNodeCall(draw,x,y,master,noiseNodeNumber,noiseNodeStore, img1Btn,unit)

def selectNoiseNode(node):
    global currentAmountOutputSelected

    currentAmountOutputSelected = selectNoiseNodeCall(draw,master,noiseNodeNumber,noiseNodeStore, currentAmountOutputSelected, node,lineNumber,lineStore)

def removeNoise():
    global noiseNodeStore
    global lineStore
    global noiseNodeNumber

    noiseNodeStore, lineStore, noiseNodeNumber = removeNoiseNodeCall(noiseNodeStore, noiseNodeNumber, lineStore, lineNumber, draw)
    removeNode(draw, master)

"""
Below are the functions for

-------------------------------------------------------- output --------------------------------------------------------

tada
"""
def find_path(draw,master):
    global newPathColor
    fancyColor = ["green","yellow","pink","orange"]
    #putting all selected nodes in a list
    nodeSearchList = []
    for x in range(outputNumber):
        if(outputStore[x!=0]):
            if(outputStore[x][1].stat==2):
                nodeSearchList.append(outputStore[x])

    if(nodeSearchList[0][1].order>nodeSearchList[1][1].order):
        temp = nodeSearchList[0]
        nodeSearchList[0] = nodeSearchList[1]
        nodeSearchList[1] = temp

    #adding them to a networkx to scan for the shortest route because networkx is lit
    path = graphShortestPath(storeNG,nodeSearchList)
    print("calculated path:",path)
    dis = len(path)-1
    print(dis)
    i = 0
    while(i<dis):
        for x in range(lineNumber):
            if(lineStore[x]!=0):
                print("current i loop: ",i)
                if(lineStore[x][1].nmb == path[i]+1 and lineStore[x][2].nmb == path[i+1]+1):
                    draw.itemconfig(lineStore[x][0],fill=fancyColor[newPathColor])
                    lineStore[x][4] = fancyColor[newPathColor]
                    print("painted the path to goal")
        i += 1
    newPathColor += 1
    selectOutput(nodeSearchList[0][1].nmb-1,draw)
    selectOutput(nodeSearchList[1][1].nmb-1,draw)

def addOutput(draw, x, y, master):
        global outputStore
        global outputNumber
        #create output
        switch = 0
        node = 0
        size = nodeSize
        print("current size: ",size)
        #set img1btn as object so that we can add .widget containing the circle id.
        img1Btn = nodeHolder()
        img1Btn.widget = draw.create_circle(x,y,size*unit.currentZoom, fill="red", tags="nodes")
        img1Btn.nmb = 0
        img1Btn.stat = 1
        img1Btn.zoom = size*unit.currentZoom
        textSize = round((size/2)*unit.currentZoom)
        img1Btn.nodeMode = []
        if(textSize<1):
            textSize = 1

        for i in range(5):
            img1Btn.nodeMode.append(IntVar())

        #use same save technique so that all the functions remain functional
        save = [img1Btn.widget,img1Btn,x,y]

        #earch if their is a empty entry.
        for m in range(outputNumber):
            if(outputStore[m]==0):
                img1Btn.nmb=m+1
                nmb = draw.create_text(x, y, text="W"+str(m+1),width=0, font=("Courier", textSize),tags="wNotation")
                save.append(nmb)
                outputStore[m] = save
                switch = 1

                #initial output
        if(outputNumber==0):
            img1Btn.nmb=1
            nmb = draw.create_text(x, y, text="W"+str(1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1
            switch = 1

        #append if no empty entry
        if(switch==0):
            img1Btn.nmb=outputNumber+1
            nmb = draw.create_text(x, y, text="W"+str(outputNumber+1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1


def removeOutput(draw,master):
    global outputStore
    global outputNumber
    #search for output and set it to 0
    removeNH(draw,master,0)
    removeNH(draw,master,1)

    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat == 2):
                for i in range(lineNumber):
                    #print("i: ",i," lineStore:",lineStore[i],"")
                    if(lineStore[i]!=0):
                        if(lineStore[i][1]==outputStore[x][1] or lineStore[i][2]==outputStore[x][1]):
                            #print("i: ",i," is deleted")
                            lineStore[i][1].stat == 2
                            draw.delete(lineStore[i][0])
                            removeNode(draw, master)
                            lineStore[i]=0
                draw.delete(outputStore[x][4])
                draw.delete(outputStore[x][0])
                outputStore[x] = 0

def selectOutput(f,draw):
    global currentAmountOutputSelected
    global lineNumber
    global outputStore
    global lineNumber
    id = outputStore[f][1]
    #each output has a stat variable which indicates state. stat == 1 is not selected, stat == 2 is selected. stat == 4 is unknown node
    if(outputStore[f][1].stat==1):
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        outputStore[f][1].stat = 2
        draw.itemconfig(outputStore[f][0],fill="pink")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill="red")
    elif(outputStore[f][1].stat==2):
        id.order = 0
        currentAmountOutputSelected = currentAmountOutputSelected - 1
        outputStore[f][1].stat = 1
        draw.itemconfig(outputStore[f][0],fill="red")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])

    elif(outputStore[f][1].stat==3):
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        outputStore[f][1].stat = 4
        draw.itemconfig(outputStore[f][0],fill="pink")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill="red")
    else:
        id.order = 0
        currentAmountOutputSelected = currentAmountOutputSelected - 1
        outputStore[f][1].stat = 3
        draw.itemconfig(outputStore[f][0],fill="blue")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])

def makeunkown(master, draw):
    global currentAmountOutputSelected
    global outputStore
    global outputNumber
    global lineStore
    global lineNumber
    global unknownNodenumber
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2):
                outputStore[x][1].stat = 4
                selectOutput(x,draw)
                unknownNodenumber +=1
            elif(outputStore[x][1].stat==4):
                outputStore[x][1].stat = 2
                selectOutput(x,draw)
                unknownNodenumber -=1
    reloadCall(subMenu,reload,currentAmountOutputSelected,0)

"""
below are the Predictor Model Selection and Immersion

-------------------------------------------------------- PMS & Immersion --------------------------------------------------------
"""

def PMS_pop(draw,master):
    popup = Tk()
    popup.wm_title("PMS choice menu")
    label = Label(popup, text="Choose which PMS function to be executed")
    label.pack(side="top", fill="x", pady=10)
    B1 = Button(popup, text="Okay", command = popup.destroy)
    B1.pack()
    B2 = Button(master, text="Okay", command = FIC(master,draw))
    B2.pack()
    popup.mainloop()

def USC(master,draw):
    global outputStore
    global number_of_nodes
    global lineNumber
    global lineStore
    global btnStore
    global outputNumber
    global NG_pms
    global NR_pms
    global NH_pms
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    #look for accessible nodes
    accessible = (np.zeros(len(NG_pms))).tolist()
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2 or outputStore[x][1].stat==4):
                accesible[x] = 1
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    #parallel condition
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)
    NG[j][i] = 0
    nodeSearchList = [outputStore[i],outputStore[j]]
    list = graphShortestPath(NG,nodeSearchList)
    for x in range(len(list)-2):
        print(x+1)
        temp = list[x+1]
        D[temp] = 1
    #loop condition
    NG = copy.deepcopy(NG_pms)
    for x in range(len(NG)):
        if(NG[x][j]):
            nodeSearchList = [outputStore[x],outputStore[j]]
            list = graphShortestPath(NG,nodeSearchList)
            for x in range(len(list)-1):
                temp = list[x]
                D[temp] = 1
    #all accesible inneighbours of Y
    for x in range(len(NG_pms)):
        if(NG_pms[j][x] and accessible[x]):
            D[x] = 1
    #all accesible through inaccesible path
    for x in range(len(NG_pms)):
        if(NG_pms[j][x] and accessible[x]==0):
            found = 1
            while(found):
                found = 0

def MIC(master,draw):
    global outputStore
    global number_of_nodes
    global lineNumber
    global lineStore
    global btnStore
    global outputNumber
    global NG_pms
    global NR_pms
    global NH_pms
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    #parallel condition
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)
    NG[j][i] = 0
    nodeSearchList = [outputStore[i],outputStore[j]]
    list = graphShortestPath(NG,nodeSearchList)
    for x in range(len(list)-2):
        print(x+1)
        temp = list[x+1]
        D[temp] = 1
    #loop condition
    NG = copy.deepcopy(NG_pms)
    for x in range(len(NG)):
        if(NG[x][j]):
            nodeSearchList = [outputStore[x],outputStore[j]]
            list = graphShortestPath(NG,nodeSearchList)
            for x in range(len(list)-1):
                temp = list[x]
                D[temp] = 1
    #step node signal
    Q = (np.zeros(len(NG_pms))).tolist()
    change = 1
    while(change):
        change = 0
        for y in range(len(Y)):
            if(Y[y]):
                for x in range(len(NG_pms)):
                    if(NH_pms[y][x]):
                        for a in range(len(NG_pms)):
                            if(D[a] and NH_pms[a][x] and Y[a]==0):
                                print(NH_pms[y])
                                print(NH_pms[a])
                                Y[a] = 1
                                Q[a] = 1
                                change = 1

    A = (np.zeros(len(NG_pms))).tolist()
    for x in range(len(Q)):
        if(D[x] and Q[x]==0):
            A[x] = 1
    msg = "D:"+str(D)+"\nA:"+str(A)+"\nQ:"+str(Q)+"\nY"+str(Y)
    popupmsg(msg)

def FIC(master,draw):
    global outputStore
    global outputNumber
    global unknownNodenumber
    global NG_pms
    global NR_pms
    global NH_pms
    global storeNG
    global storeNH
    global storeNR
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            D[x]=1;
    change = 1
    while(change):
        print("D:")
        print(D)
        print("Y:")
        print(Y)
        change = 0
        #looking for new outputs
        for u in range(len(Y)):
            if(Y[u]):
                for x in range(len(Y)):
                    if(NH_pms[u][x]):
                        for y in range(len(Y)):
                            if(NH_pms[y][x]):
                                if(Y[y]==0 and D[y]):        #Checking if it is a new output
                                    change = 1
                                    Y[y]=1
                                    print(NG_pms[y])
                                    for a in range(len(NG_pms)):
                                        if(NG_pms[y][a]):
                                            D[a]=1;
                                            print(a)
    D_indirect, Y_indirect = PMS(draw,master)
    A = (np.zeros(len(NG_pms))).tolist()
    for x in range(len(A)):
        if(D[x] and Y[x]==0):
            A[x]=1
    Blocking_possible = (np.zeros(len(D))).tolist()
    for x in range(len(D)):
        if(D_indirect[x] and D[x]==0):
            Blocking_possible[x]=1
    #condition 1: connection from Y
    for x in range(len(Blocking_possible)):
        if(Blocking_possible[x]):
            for y in range(len(Y)):
                if(Y[y] and NG_pms[x][y]):
                    Blocking_possible[x]=0
    #condition 2: connection through e with A
    for x in range(len(Blocking_possible)):
        if(Blocking_possible[x]):
            for y in range(len(A)):
                if(NH_pms[x][y]):
                    for a in range(len(A)):
                        if(NH_pms[a][y] and A[a]):
                            Blocking_possible[x]=0
    Blocking = Blocking_possible
    msg = "D:"+str(D)+"\nY:"+str(Y)+"\nA:"+str(A)+"\nBlocking"+str(Blocking)
    popupmsg(msg)

def PMS_call(master,draw):
    D,Y = PMS(master,draw)
    msg = "D:"+str(D)+"\nY:"+str(Y)
    popupmsg(msg)

def PMS(master, draw):
    global outputStore
    global outputNumber
    global unknownNodenumber
    global NG_pms
    global NR_pms
    global NH_pms
    global storeNG
    global storeNH
    global storeNR
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a


    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the D and Y sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            D[x]=1;
    change = 1
    while(change):
        print("D:")
        print(D)
        print("Y:")
        print(Y)
        change = 0
        Unknownnodes = []
        for x in range(len(D)):
            if(D[x] or Y[x]):
                Unknownnodes.append(0)
            else:
                Unknownnodes.append(1)
                unknownNodenumber +=1
        NG = copy.deepcopy(NG_pms)
        NH = copy.deepcopy(NH_pms)
        NR = copy.deepcopy(NR_pms)
        if(unknownNodenumber>0):
            G = []
            B = []
            R = []
            G, B, R = Immersion(NG,NR,NH,Unknownnodes,draw,master)
        else:
            G = NG
            B = NH
            R = NR
        #looking for new outputs
        for u in range(len(Y)):
            if(Y[u]):
                for x in range(len(B)):
                    if(B[u][x]):
                        for y in range(len(B)):
                            if(B[y][x]):
                                print(y)
                                if(Y[y]==0 and D[y]):        #Checking if it is a new output
                                    change = 1
                                    Y[y]=1
                                    for a in range(len(NG_pms)):
                                        if(NG_pms[y][a]):
                                            D[a]=1;
    return D,Y

def popupmsg(msg):
    popup = Tk()
    popup.wm_title("!")
    label = Label(popup, text=msg)
    label.pack(side="top", fill="x", pady=10)
    B1 = Button(popup, text="Okay", command = popup.destroy)
    B1.pack()
    popup.mainloop()

def Unknownnodesbottom(NG, NR, NH, Unknownnodes):
    global unknownNodenumber
    correct_nodes = 0
    len_Unknownnodes = len(Unknownnodes)-1
    while(unknownNodenumber>correct_nodes):
        #Check if the bottom node is a unknown node
        if(Unknownnodes[len_Unknownnodes-correct_nodes]):
            correct_nodes += 1
        #If not, place the first unknown node at the bottom
        else:
            a = 0
            x = 0
            while(a==0):
                if(Unknownnodes[x]):
                    #Switch the nodes in NG matrix
                    row1 = copy.deepcopy(NG[x])
                    row2 = copy.deepcopy(NG[len_Unknownnodes-correct_nodes])
                    NG[x] = row2
                    NG[len_Unknownnodes-correct_nodes] = row1
                    column1 = []
                    column2 = []
                    for y in range(len(NG)):
                        column1.append(NG[y][x])
                        column2.append(NG[y][len_Unknownnodes-correct_nodes])
                    for y in range(len(NG)):
                        NG[y][x] = column2[y]
                        NG[y][len_Unknownnodes-correct_nodes] = column1[y]
                    #Switch the nodes in NH matrix
                    rowNH1 = copy.deepcopy(NH[x])
                    rowNH2 = copy.deepcopy(NH[len_Unknownnodes-correct_nodes])
                    NH[x] = rowNH2
                    NH[len_Unknownnodes-correct_nodes] = rowNH1
                    #Switch the nodes in NR matrix
                    rowNR1 = copy.deepcopy(NR[x])
                    rowNR2 = copy.deepcopy(NR[len_Unknownnodes-correct_nodes])
                    NR[x] = rowNR2
                    NR[len_Unknownnodes-correct_nodes] = rowNR1
                    #Switch the nodes in Unknownnodes list
                    Unknownnodes[x] = 0
                    Unknownnodes[len_Unknownnodes-correct_nodes] = 1
                    a = 1
                x +=1
    #change NG to a list if it is not already
    if(False==(isinstance(NG, list))):
        NG = NG.tolist()
    #change NH to an array if it is not already
    if(False==(isinstance(NH,np.ndarray))):
        NH = np.array(NH)
    if(False==(isinstance(NR, list))):
        NR = NR.tolist()
    return NG, NR, NH, Unknownnodes

def Immersion_call(master,draw):
    global storeNG
    global storeNH
    global storeNR
    NG, NR, NH, Unknownnodes= toAdjacencyMatrix(draw,master)
    G, B, R = Immersion(NG,NR,NH,Unknownnodes,draw,master)
    clearWindow(draw,0)
    storeNG = G
    storeNH = B
    storeNR = R
    plotMatrix(draw,master,1)

def Immersion(NG,NR,NH,Unknownnodes,draw,master):
    global NG_pms
    global NR_pms
    global NH_pms
    global outputNumber
    global outputStore
    global lineStore
    global lineNumber
    global unknownNodenumber
    global storeNG
    global storeNH
    global storeNR
    A1 = []
    L = []
    L11 = []
    L12 = []
    L21 = []
    L22 = []
    B = []
    Unknownnodes_start = copy.deepcopy(Unknownnodes)
    Unknownnodes_start_1 = copy.deepcopy(Unknownnodes)
    NG, NR, NH, Unknownnodes= Unknownnodesbottom(NG, NR, NH, Unknownnodes)
    #Change NG into a Laplacian form L
    #creating Diagonal A1
    for x in range(len(NG)):
        A1.append(0)
        for y in range(len(NG)):
            A1[x]=A1[x]+NG[x][y]
    for x in range(len(NG)):
        new = []
        for y in range(len(NG)):
            if(y==x):
                new.append(A1[x])
            else:
                new.append(-NG[x][y])
        L.append(new)
    for x in range(len(NG)-unknownNodenumber):
        new = []
        for y in range(len(NG)-unknownNodenumber):
            new.append(L[x][y])
        L11.append(new)
    for x in range(unknownNodenumber):
        new = []
        for y in range(len(NG)-unknownNodenumber):
            new.append(L[len(NG)-unknownNodenumber+x][y])
        L12.append(new)
    for x in range(len(NG)-unknownNodenumber):
        new = []
        for y in range(unknownNodenumber):
            new.append(L[x][len(NG)-unknownNodenumber+y])
        L21.append(new)
    for x in range(unknownNodenumber):
        new = []
        for y in range(unknownNodenumber):
            new.append(L[len(NG)-unknownNodenumber+x][len(NG)-unknownNodenumber+y])
        L22.append(new)
    L11 = np.array(L11)
    L12 = np.transpose(np.array(L12))
    L21 = np.transpose(np.array(L21))
    #if the inverse of L22 is not available use the pseudo inverse
    if(np.linalg.det(L22)==0):
        L22 = np.linalg.pinv(np.array(L22))
    else:
        L22 = np.linalg.inv(np.array(L22))
    #Use kron reduction to calculate the new laplacian
    L12_22 = L12.dot(L22)
    L12_22_21 = L12_22.dot(L21)
    Lhat = np.subtract(L11,L12_22_21)
    #Change the laplacian into an Adjacency matrix
    A = np.subtract(Lhat,np.diag(np.diag(Lhat)))
    A = A.tolist()
    #unweigh the matrix A
    for x in range(len(A)):
        for y in range(len(A)):
            if(A[x][y]!=0):
                A[x][y]=1
            else:
                A[x][y]=0;
    #adding the old nodes with no connection at the bottom
    G = []
    for x in range(len(NG)):
        new = []
        if(x>len(NG)-1-unknownNodenumber):
            for y in range(len(NG)):
                new.append(0)
        else:
            for y in range(len(NG)):
                if(y>len(NG)-1-unknownNodenumber):
                    new.append(0)
                else:
                    new.append(A[x][y])
        G.append(new)
    #switching to the right position

    B = NH
    #Find the nodes to which the unknown nodes used to point (before Immersion)
    itteration = 0
    while(itteration<unknownNodenumber):
        for x in range(len(B)):
            if(Unknownnodes[x]):          #unknown node is found
                for y in range(len(B[0])):
                    if(NG[y][x]):       #nodes to which the unknown node point
                        for a in range(len(B[0])):
                            if(NH[x][a]):
                                NH[y][a] = 1
        itteration += 1

    R = copy.deepcopy(NR)
    #Same computation for NR as for NH
    itteration = 0
    while(itteration<unknownNodenumber):
        for x in range(len(R)):
            if(Unknownnodes[x]):          #unknown node is found
                for y in range(len(R)):
                    if(NG[y][x]):       #nodes to which the unknown node point
                        for a in range(len(R)):
                            if(NR[x][a]):
                                R[y][a] = 1
        itteration += 1
    switched_nodes = 0
    len_Unknownnodes = len(Unknownnodes_start)-1
    while(unknownNodenumber>switched_nodes):
        #Check if the bottom node is a unknown node
        if(Unknownnodes_start[len_Unknownnodes-switched_nodes]):
            switched_nodes += 1
        #If not, place the first unknown node at the bottom
        else:
            a = 0
            x = 0
            while(a==0):
                if(Unknownnodes_start[x]):
                    #Switch the nodes in NG matrix
                    row1 = copy.deepcopy(G[x])
                    row2 = copy.deepcopy(G[len_Unknownnodes-switched_nodes])
                    G[x] = row2
                    G[len_Unknownnodes-switched_nodes] = row1
                    column1 = []
                    column2 = []
                    for y in range(len(G)):
                        column1.append(G[y][x])
                        column2.append(G[y][len_Unknownnodes-switched_nodes])
                    for y in range(len(G)):
                        G[y][x] = column2[y]
                        G[y][len_Unknownnodes-switched_nodes] = column1[y]
                    #Switch the NH back
                    rowNH1 = copy.deepcopy(B[x])
                    rowNH2 = copy.deepcopy(B[len_Unknownnodes-switched_nodes])
                    B[x] = rowNH2
                    B[len_Unknownnodes-switched_nodes] = rowNH1
                    #Switch the NR same as NH
                    rowNR1 = copy.deepcopy(R[x])
                    rowNR2 = copy.deepcopy(R[len_Unknownnodes-switched_nodes])
                    R[x] = rowNR2
                    R[len_Unknownnodes-switched_nodes] = rowNR1
                    #Switch the nodes in Unknownnodes list
                    Unknownnodes_start[x] = 0
                    Unknownnodes_start[len_Unknownnodes-switched_nodes] = 1
                    a = 1
                x +=1
    print("New NG after Immersion is:")
    print(G)
    #Set the new NH as the old NH
    r = 0
    B = B.tolist()
    for x in range (len(Unknownnodes_start_1)):
        if(Unknownnodes_start_1[x]):
            new = []
            for y in range(len(B[0])):
                new.append(0)
            B[x]=new
            R[x]=new
    #        r = r + 1
            Unknownnodes_start_1[x] = 0
            unknownNodenumber -= 1
    print("New NH after Immersion is:")
    B = np.array(B)
    print(B)
    print("End of Immersion")
    return G, B, R

"""
below are the remaining

-------------------------------------------------------- Remaining --------------------------------------------------------
"""

def Dashed_line(draw,master):
    global lineshow
    global lineStore
    global lineNumber
    global overlay

    #only in the noise view dashed lines are existing
    if(overlay):
        if(lineshow):
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "white")
            lineshow = 0
        else:
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "black")
            lineshow = 1

def clearWindow(canvas,canReset):
    #remove everythin and set all global to 0
    global number_of_nodes
    global outputNumber
    global btnStore
    global outputStore
    global noiseStore
    global noiseNumber
    global excitationNumber
    global excitationStore
    global currentAmountOutputSelected
    global lineNumber
    global lineStore
    global noiseNodeStore
    global noiseNodeNumber
    global storeNG
    global storeNR
    global storeNH
    global overlay
    global unit
    global currentView
    canvas.delete("all")
    number_of_nodes = 0
    outputNumber = 0
    btnStore = []
    outputStore = []
    noiseStore = []
    noiseNumber = 0
    excitationStore = []
    excitationNumber = 0
    currentAmountOutputSelected = 1
    """
    ^^moet het niet 1 zijn???^^
    """
    linestore = 0
    lineNumber = 0
    noiseNodeNumber = 0
    noiseNodeStore = []
    storeNG = storeNR = storeNH = []
    overlay = 0
    currentview = 0
    if(canReset==1):
        excitationNumber = 0
        if(unit.currentZoom > 1):
            unit.canvas.scale('all', unit.currentZoom, unit.currentZoom, 1, 1)
        if(unit.currentZoom < 1):
            unit.canvas.scale('all', 1, 1, unit.currentZoom, unit.currentZoom)
        unit.currentZoom = 1



#Deze functie word aangeroepen van uit het menu en haalt dan 2 nodes er uit die hij door geeft aan connectoutput
def connectCall(draw,master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    node1 = 0
    node2 = 0

    #serach first for selected outputs
    for x in range(outputNumber):
        if(outputStore[x][1].stat==2):
            if(outputStore[x][1]!=node1 and node1==0):
                node1 = outputStore[x]
            elif(node2!=outputStore[x][1]):
                node2 = outputStore[x]

    if(overlay==1):
        node2 = 0
        for x in range(noiseNodeNumber):
            if(noiseNodeStore[x][1].stat==2):
                if(noiseNodeStore[x][1]!=node2 and node2==0):
                    node2 = noiseNodeStore[x]
                    #print("found noise at: ",node2," linking to ",node1)


    #check if the node is not the same or not 0.
    if((node1==node2) or (node1 == 0 or node2 == 0)):
        print("error occured with node selection")

    else:
        #check for which order they are selected so that the last selected is the target module and the first the origin.
        if(node1[1].order > node2[1].order):
            connectOutputs(node2,node1,draw,master,1)
        else:
            connectOutputs(node1,node2,draw,master,1)
        xObj, yObj = trueCoordinates(draw,node1)
        circleScan(draw,master,xObj,yObj)
        if(overlay==0):
            xObj, yObj = trueCoordinates(draw,node2)
            circleScan(draw,master,xObj,yObj)
        else:
            selectNoiseNode(node2[1])

#connect outputs is nu 2 functies zodat je via plotmatrix ook connectOutputs direct kan aangroepen
def connectOutputs(node1,node2,draw,master, placeBtn):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    temp = 0
    node3 = 0


    for x in range(lineNumber):
        if(lineStore[x]!=0):
            if(node1[1]==lineStore[x][1] and node2[1]==lineStore[x][2]):
                temp = 1
    if(node1==node2):
        temp = 1
    #make sure that the connection is not made already or the nodes are the same
    #else make the connection
    if(temp==0):
        node1[2],node1[3] = trueCoordinates(draw,node1)
        node2[2],node2[3] = trueCoordinates(draw,node2)
        x_middle = (node2[2] + node1[2])/2
        y_middle = (node1[3] + node2[3])/2

        #draw the curve
        #slope
        if((node2[2]-node1[2])!=0):
            theta = math.degrees(math.atan((node2[3]-node1[3])/(node2[2]-node1[2])))
        else:
            theta = 90;
        length_line = math.sqrt(math.pow(node2[2]-node1[2],2)+math.pow(node2[3]-node1[3],2))/2
        height_curve = length_line/3
        if(node1>node2):
            x_transfer = x_middle + math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle - math.sin(math.radians(90-theta))*height_curve
        else:
            x_transfer = x_middle - math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle + math.sin(math.radians(90-theta))*height_curve
        #draw the transfer
        #set btn when needed.
        if(placeBtn):
            addNode(draw,(x_transfer+x_middle)/2,(y_transfer+y_middle)/2,master,node1,node2)
            for x in range(number_of_nodes):
                if(btnStore[x]!=0):
                    if(btnStore[x][2]==(x_transfer+x_middle)/2 and btnStore[x][3]==(y_transfer+y_middle)/2):
                        node3 = btnStore[x]
        else:
            #create a fake note
            node3 = [1,1]
        #end of draw the tranfer

        if(placeBtn):
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true")
        else:
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true", width=0.01, dash=(5, 10))
        tempStore = [lineWidget, node1[1], node2[1], node3[1],"black"]
        lineStore.insert(lineNumber,tempStore)
        lineNumber = lineNumber+1


        #draw the arrow

        gamma = 45/2 #adjust the angle of the arrow
        length_arrow = 5*unit.currentZoom #adjust the lenght of the arrow
        """
        sign_2 = 1
        if(node1[2]>node2[2]):
            sign_2 = -1

        p1 = [0,0]
        p2 = [0,0]
        p3 = [0,0]
        p1[0] = node1[2]
        p1[1] = node1[3]
        p2[0] = node2[2]
        p2[1] = node2[3]
        p3[0] = node3[2]
        p3[1] = node3[3]
        xa, ya, radius = define_circle(p1, p2, p3)
        #function y = -ya + sqrt(-(x+xa)^2 radius^2)
        x_arrow0 = (x_middle+node2[2])/2
        y_arrow0 = ya + math.sqrt(math.pow(radius,2)-math.pow((x_arrow0-xa),2)) -1
        #derivative y'
        #slope = (x_arrow0-xa)/math.sqrt(math.pow(radius,2)-math.pow((x_arrow0-xa),2))
        epsilon = math.degrees(math.atan(((node2[3]-y_arrow0)/(node2[2]-x_arrow0))))

        test 2

        sign_2 = 1
        if(node1[2]<node2[2]):
            length = node2[2]-node1[2]
        else:
            length = node1[2]-node2[2]
            sign_2 = -1
        x_axis_left = length/2
        x_axis_middle = 0
        y_axis_bottom = 0
        y_axis_middle = height_curve
        # make function y = ax^2 + b
        b = y_axis_middle
        a = -b/(math.pow(x_axis_left,2))
        #use slope to calculate degree y' = 2ax
        x_arrow = -length/4
        y_arrow = a*math.pow(x_arrow,2) + b
        slope = 2*a*x_arrow
        slope_degrees = math.degrees(math.atan(slope))
        print(slope_degrees)
        print(theta)
        #translate back to the actual position
        epsilon = theta+sign_2*slope_degrees
        x_arrow0 = node1[2]+ x_arrow*math.cos(math.radians(theta))-y_arrow*math.sin(math.radians(theta))
        y_arrow0 = node1[3]+ y_arrow*math.cos(math.radians(theta))+x_arrow*math.sin(math.radians(theta))
        """

        sign_2 = 1
        if(node1[2]>node2[2]):
            sign_2 = -1

        if(node1>node2):
            x_arrow0 = (x_middle+node2[2])/2 + math.cos(math.radians(90-theta))*height_curve/5.4*2
            y_arrow0 = (y_middle+node2[3])/2 - math.sin(math.radians(90-theta))*height_curve/5.4*2
            epsilon = 180-gamma-theta-90-6*sign_2
        else:
            x_arrow0 = (x_middle+node2[2])/2 - math.cos(math.radians(90-theta))*height_curve/5.4*2
            y_arrow0 = (y_middle+node2[3])/2 + math.sin(math.radians(90-theta))*height_curve/5.4*2
            epsilon = 180-gamma-theta-90+6*sign_2

        x_arrow1 = x_arrow0 - sign_2*math.sin(math.radians(epsilon))*length_arrow
        y_arrow1 = y_arrow0 - sign_2*math.cos(math.radians(epsilon))*length_arrow
        alpha = gamma+epsilon
        alpha_hypotenusa = sign_2*math.sin(math.radians(gamma))*length_arrow*2
        x_arrow2 = x_arrow1 - math.cos(math.radians(alpha))*alpha_hypotenusa
        y_arrow2 = y_arrow1 + math.sin(math.radians(alpha))*alpha_hypotenusa
        tempStore2 = [draw.create_line(x_arrow1, y_arrow1, x_arrow0,y_arrow0, x_arrow2, y_arrow2),node1[1],node2[1],node3[1],"black"]
        lineStore.insert(lineNumber,tempStore2)
        lineNumber = lineNumber+1

        draw.tag_raise("nodes")
        draw.tag_raise("rect")
        draw.tag_raise("wNotation")

def define_circle(p1, p2, p3):
    """
    Returns the center and radius of the circle passing the given 3 points.
    In case the 3 points form a line, returns (None, infinity).
    """
    temp = p2[0] * p2[0] + p2[1] * p2[1]
    bc = (p1[0] * p1[0] + p1[1] * p1[1] - temp) / 2
    cd = (temp - p3[0] * p3[0] - p3[1] * p3[1]) / 2
    det = (p1[0] - p2[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p2[1])

    if abs(det) < 1.0e-6:
        return (None, np.inf)

    # Center of circle
    cx = (bc*(p2[1] - p3[1]) - cd*(p1[1] - p2[1])) / det
    cy = ((p1[0] - p2[0]) * cd - (p2[0] - p3[0]) * bc) / det

    radius = np.sqrt((cx - p1[0])**2 + (cy - p1[1])**2)
    return (cx, cy, radius)

def addWidget(input):
    #set the clickOperation variable
    global clickOperation
    clickOperation = input


def clickEvent(event):
    #on button press perform an action based on click clickOperation
    global clickOperation
    x = draw.canvasx(event.x)
    y = draw.canvasy(event.y)
    if(clickOperation==0 and currentView == 1):
        circleScan(draw,master,x,y)
    if(clickOperation==1):
        addNode(event.widget, x, y, master)
        clickOperation=0

    if(clickOperation==2):
        addOutput(event.widget, x, y, master)
        print("node added at: ",x,",",y)
        clickOperation=0

    if(clickOperation==3):
        addNoiseNode(draw, x, y, master)
        clickOperation=0

def circleScan(draw,master,x,y):
    global currentAmountOutputSelected
    global outputStore
    #this function scans the mouse click and tries to find if it is within a circle
    print("scanning for button at: ",x,",",y)
    #draw.create_circle(x,y,10,fill="green")
    #circle through all unknown nodes to check within their radius
    for f in range(outputNumber):
        if(outputStore[f]!=0):
            #the zoom function and drag messes with the old coordintes with trueCoordinates you obtain the in that view correct coordinates
            xObj, yObj = trueCoordinates(draw,outputStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < nodeSize*unit.currentZoom):
                selectOutput(f,draw)

    for f in range(noiseNodeNumber):
        if(noiseNodeStore[f]!=0):
            xObj, yObj = trueCoordinates(draw,noiseNodeStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < nodeSize*unit.currentZoom):
                id = noiseNodeStore[f]
                selectNoiseNode(id)

    for f in range(number_of_nodes):
        if(btnStore[f]!=0):
            if(btnStore[f]!=0):
                xObj, yObj = trueCoordinates(draw,btnStore[f])
                yObj -= nodeSize*unit.currentZoom*0.4
                height = nodeSize*unit.currentZoom*0.7
                width = nodeSize*unit.currentZoom
                #print("searching for x: ",xObj," y: ",yObj)
                #print(x,",",y)
                if(xObj-width<x and x<xObj+width):
                    if(yObj-height<y and y<yObj+height):
                        if(btnStore[f][1].stat==1):
                            draw.itemconfig(btnStore[f][0], fill="yellow")
                            btnStore[f][1].stat=2
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="red")

                        else:
                            if(btnStore[f][1].known == 1):
                                draw.itemconfig(btnStore[f][0], fill="green")
                            elif(btnStore[f][1].pms == 1):
                                draw.itemconfig(btnStore[f][0], fill="blue")
                            else:
                                draw.itemconfig(btnStore[f][0], fill="cyan")
                            btnStore[f][1].stat=1
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="black")
    #reload the right view if a node is selected
    selectedNode = 0
    if(currentAmountOutputSelected == 2):
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat==2 or outputStore[x][1].stat==4):
                    selectedNode=outputStore[x][1]
                    print("found node and giving it to reloadCall")
    reloadCall(subMenu,reload,currentAmountOutputSelected,selectedNode)




def trueCoordinates(draw,node):
    #draw.coords obtains the current coordinates based on the widget id. + the radius multiply by zoom to shift the left corner of the widget to the center.
    xObj = draw.coords(node[0])[0]+nodeSize*unit.currentZoom
    yObj = draw.coords(node[0])[1]+nodeSize*unit.currentZoom
    #xObj = draw.canvasx(node[2])
    #yObj = draw.canvasy(node[3])
    return xObj, yObj

""""
    Zoom_buttons(unit.imscale)

def Zoom_buttons(scale):
    global scale_prev
    global number_of_nodes
    global btnStore
    if(scale_prev!=scale):
        scale_prev = scale
        for x in range(number_of_nodes):
            if(btnStore[x]!=0):
                btnStore[x][1].configure(height=int(scale*10),width=int(scale*30))
                btnStore[x][1].pack()
"""

"""
Below you will find the basic setup of the grid

-------------------------------------------------------- Grid interface setup and initialization --------------------------------------------------------
"""

# creating Tk window
master = Tk()
master.configure(background="gray")
master.title("Delivery Demo")
#set initial size
master.geometry("1500x1500")

#create a grid which can reize with the resizing of the box
Grid.rowconfigure(master, 0, weight=1)
Grid.columnconfigure(master, 0, weight=1)
masterFrame = Frame(master)
masterFrame.grid(row=0, column=0, sticky=N+S+E+W)
Grid.rowconfigure(masterFrame, 0, weight=1)
Grid.rowconfigure(masterFrame, 1, weight=100)
Grid.columnconfigure(masterFrame, 0, weight=100)
Grid.columnconfigure(masterFrame, 1, weight=1)

#seperating the menu in different frames which will hold all the components so that it is easier to use .grid for button placemant
#main menu is for the upper buttons, canvas is for draw, subMenu is for the component selection
mainMenu = Frame(masterFrame, bg="gray")
canvas = Frame(masterFrame, bg="white")
subMenu = Frame(masterFrame, bg="gray")

#set each frame in the grid
mainMenu.grid(row=0,sticky=N+S+E+W)
canvas.grid(row=1, sticky=N+S+E+W)
subMenu.grid(row=0, column=1, rowspan=2, sticky=N+S+E+W)

#create a canvas called draw in the canvas frame
draw = Canvas(canvas, bg="white")
draw.pack(fill="both", expand=True)

layout = [
"circular",
"kamada_kawai",
"spring",
"spectral",
"spiral"
]

layoutMethod = StringVar(master)
layoutMethod.set(layout[1])

#bind functions to events
initMainMenu(mainMenu, draw)
reload = initSubMenu(subMenu)

#set the draw canvas with the scroll and pan option
unit = Zoom_Advanced(draw)
#bind button Release to the clickevent
unit.canvas.bind("<ButtonRelease-1>",clickEvent)
mainloop()
