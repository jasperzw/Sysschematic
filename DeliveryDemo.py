# Importing tkinter module
from tkinter import *
from matImport import readFile, toAdjacencyMatrixCall, generateGraph, graphShortestPath, graphDisjointPath, treeAllocation, mergeTree, saveToFile
from tkinter.filedialog import askopenfilename
import math
from Scrollwindow import *
from node import removeNodeCall
from noise import addNoiseNodeCall, selectNoiseNodeCall, removeNoiseNodeCall
#from matlabCaller import test_identifiability_caller
import numpy as np
import networkx as nx
import copy
import random
from colors import COLORS

"""
initializing all global components
The structure used for both btnStore and outputStore is as follows [windowsId, WidgetObject, x, y]
windowId is the canvas id generated by create_text and widgetObject is the object you can edit to change color and such
the noise store has an extra entry which comes down to [windowsId, WidgetObject, x, y, outputObject] where output Object is the object of the output on which the noise is applied
tempStore follows [widgetId, objectId1, objectId2] object 1 en object 2 is the objects between which the line is connected
widgetId is what you call to remove it from the canvas in draw.delete(widgetId)

lineStore[x][1] and lineStore[x][2] are the modules connected by the line and lineStore[x][3] is the transfer
"""
number_of_nodes = 0
btnStore = []
lineStore = [[]]
lineNumber = 0
outputStore = []
noiseStore = []
connect = []
noiseNumber = 0
outputNumber = 0
excitationStore = []
excitationNumber = 0
noiseNodeNumber = 0
noiseNodeStore = []
nodeSize = 5
storeNG = storeNR = storeNH = []
NG_pms = NR_pms = NH_pms = []
Unknownnodes = []
lineshow = 1
overlay = 0 #overlay value 0 means the NG matrix and overlay 1 is the Noise overlay
currentAmountOutputSelected = 1 #this variable is so we know the order that outputs are connected. it is not zero because unselected are 0
#global declare is unnecessary since they are declared in the upper script outside any function
#variable which indicates if a click means a module add
clickOperation=0
currentView = 1
butTestStore = []
butTestNumber = 0
unknownNodenumber = 0
newPathColor = 0
currentGroup = 1
fancyColor = COLORS
#fancyColor = ["green","yellow","orange","blue","cyan","dark sea green","khaki","lightSteelBlue1","pink","lime","black"]
treeStore = []

class nodeHolder():
     nmb = 0
     group = 0

#initializes the main menu. you have to pass the mainmenu frame and the canvas so that it could pass the canvas id when clearing it
def initMainMenu(frame, canvas):

    #column 0
    Button(frame, text="load .mat file", command= lambda: loadMat(draw, master), height = 1, width=20).grid(row=0, padx=2, pady=2)
    Button(frame, text="export .mat file", command= lambda: toFile(draw, master), height = 1, width=20).grid(row=1, padx=2, pady=2)
    Button(frame, text="change node view", command= lambda: switchView(draw, master), height = 1, width=20).grid(row=2, padx=2, pady=2)

    #column 1
    Button(frame, text="Options", height = 1, width=20).grid(row=0, column=1, padx=2, pady=2)
    Button(frame, text="Clear window", command= lambda: clearWindow(canvas,1), height = 1, width=20).grid(row=2, column=1, padx=2, pady=2)

    #column 2
    Button(frame, text="load noise view", command= lambda: plotNoise(draw,master), height = 1, width=20).grid(row=0, column=2, padx=2, pady=2)
    Button(frame, text="load transfer view", command= lambda: plotMatrix(draw,master,0), height = 1, width=20).grid(row=1, column=2, padx=2, pady=2)
    Button(frame, text="change line view", command= lambda: Dashed_line(draw,master), height = 1, width=20).grid(row=2, column=2, padx=2, pady=2)



    #column 3
    OptionMenu(frame, viewMethod, *views).grid(row=0, column=3)
    OptionMenu(frame, layoutMethod, *layout).grid(row=1, column=3)
    Button(frame, text="PMS", command= lambda: PMS_option(draw,master), height = 1, width=20, bg="purple").grid(row=1, column=2, padx=2, pady=2)
    OptionMenu(frame, layoutMethod1, *layout1).grid(row=2, column=3)
#same as main menu initializes the submenu
def initSubMenu(frame):

    Button(frame, text="add node", command= lambda: addWidget(2), height = 1, width=20, bg="yellow").pack(padx=2, pady=2)
    Button(frame, text="connect Transfer/module", command= lambda: connectCall(draw,master), height = 1, width=20, bg="yellow").pack(padx=2, pady=2)
    Button(frame, text="Remove transfer", command= lambda: removeNode(draw, master),  height = 1, width=20, bg="yellow").pack(padx=2, pady=2)
    Button(frame, text="Perform test identifiability", command= lambda: testIdentifiability(master, draw), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Find shortest path", command= lambda: find_path(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Find disjoint path", command= lambda: paint_disjoint_path(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Create minimum tree", command= lambda: draw_tree(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="merge maximum tree", command= lambda: find_maximum_tree(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Immersion", command= lambda: Immersion_call(master, draw), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Make group", command= lambda: makeGroup(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)
    Button(frame, text="Remove group", command= lambda: removeGroup(draw,master), height = 1, width=20, bg="purple").pack(padx=2, pady=2)

    #in reload every button or Checkbox is stored which is reloaded on calling reloadCall when currentAmountOutputSelected > 1
    #check if correct commit information
    reload = [
    Button(frame, text="toggle transfer known", command= lambda: toggleTransfer(master, draw), height = 1, width=20, bg="yellow"),
    Button(frame, text="toggle transfer pms", command= lambda: PMSTransfer(master, draw), height = 1, width=20, bg="yellow"),
    Button(frame, text="remove node", command= lambda: removeOutput(draw, master), height = 1, width=20, bg="yellow"),
    Button(frame, text="add external excitation", command= lambda: addNHCall(master, draw,1), height = 1, width=20, bg="yellow"),
    Button(frame, text="remove external excitation", command= lambda: removeNH(draw,master,1), height = 1, width=20, bg="yellow"),
    Button(frame, text="add noise", command= lambda: addNHCall(master, draw,0), height = 1, width=20, bg="yellow"),
    Button(frame, text="remove noise", command= lambda: removeNH(draw,master,0), height = 1, width=20, bg="yellow"),
    Button(frame, text="Make unknown", command= lambda: makeunknown(master, draw), height = 1, width=20, bg="yellow"),
    Checkbutton(frame, text="excitation measurable", height = 1, width=20),
    Checkbutton(frame, text="noise measurable", height = 1, width=20),
    Checkbutton(frame, text="Blue", height = 1, width=20),
    Checkbutton(frame, text="Yellow", height = 1, width=20),
    Checkbutton(frame, text="Green", height = 1, width=20),
    ]
    return reload


def toFile(draw,master):
    #In this function we will store the entire matrix in a .mat file so that it can be reloaded again in the system.
    #first we want to retrieve the current matrix
    storeNG, storeNR, storeNH, Unknownnodes = toAdjacencyMatrix(draw,master)
    #ask how to call the file
    call = popupWindow(master)
    master.wait_window(call.top)
    name = call.value + ".mat"
    print("saved file under:",name)
    #call saveToFile to perform scipy .mat save function
    saveToFile(storeNG,storeNR,storeNH,Unknownnodes,name)


def toggleTransfer(master,draw):
    #this function toggles any select node from begin known
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            #.stat == 2 means that the node is selected
            if(btnStore[x][1].stat==2):
                if(btnStore[x][1].known==0):
                    btnStore[x][1].known = 1
                else:
                    btnStore[x][1].known = 0
                #true coordinates is called to perform the transform of the coordinates to the current view and then give them to deselect the node
                x, y = trueCoordinates(draw,btnStore[x])
                circleScan(draw,master,x,y)

def PMSTransfer(master,draw):
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].stat==2):
                if(btnStore[x][1].pms==0):
                    btnStore[x][1].pms = 1
                else:
                    btnStore[x][1].pms = 0
                x, y = trueCoordinates(draw,btnStore[x])
                circleScan(draw,master,x,y)

"""
below are all the functions for

-------------------------------------------------------- Adjacency Matrix --------------------------------------------------------

used to plot adjency matrix and return everything to Adjacency matrix
"""

def testIdentifiability(master,draw):
    NG = []
    NR = []
    NH = []
    KnownNodes = []
    #set everything first to zero
    print("test: ",noiseNumber)
    for x in range(outputNumber):
        new = []
        for y in range(outputNumber):
            new.append(0)
        NG.append(new)
        new = []
        if(noiseNumber!=0):
            for y in range(noiseNumber):
                new.append(0)
        NH.append(new)
        new = []
        if(excitationNumber!=0):
            for y in range(excitationNumber):
                new.append(0)
        NR.append(new)
        KnownNodes.append(0)

    #run the above functions to generate a corresponding NG NR and NH matrix which we then fill with the measurable signals

    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].known==1):
                NG[btnStore[x][5]-1][btnStore[x][4]-1] = 1


    #set kown transfer to measurable in NG matrix
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            print("nodeMode: ", outputStore[x][1].nodeMode[0].get() ," found at: ", outputStore[x][0])
            if(outputStore[x][1].nodeMode[0].get()==1):
                        NR[x][x] = 1
                        print("set excitation to high")
            if(outputStore[x][1].nodeMode[1].get()==1):
                for y in range(noiseNumber):
                    if(noiseStore[y][4]==outputStore[x][1]):
                        NH[x][noiseStore[y][1].nmb-1]=1
                        print("set noise to high")

    #check each node if they have the nosie or excitation measurable selected and the note that in the NH and NR matrix

    adjG, adjR, adjH, unknown = toAdjacencyMatrix(draw,master)

    replaceH = []
    for x in range(len(adjH)):
        new = []
        for y in range(len(adjH[0])):
            new.append(adjH[x][y])
        replaceH.append(new)


    #this function is simpely their because the NH matrix is not changed from when it was imported and needs to go in a different format which matlab can interpret
    adjH = replaceH

    #call the test_identifiability_caller to transfer everything to matlab


    print("NG matrix: ",NG)
    print("--------------------------------------------------------------------------------------")
    print("NR matrix: ",NR)
    print("--------------------------------------------------------------------------------------")
    print("NH matrix: ",NH)
    print("//////////////////////////////////////////////////////////////////////////////////////")

    identifiability, identifiability_nodes, identifiability_modules = test_identifiability_caller(adjG,adjR,adjH,NG,NR,NH)

    print("found the following")
    print("NG matrix: ",identifiability)
    print("--------------------------------------------------------------------------------------")
    print("NR matrix: ",identifiability_nodes)
    print("--------------------------------------------------------------------------------------")
    print("NH matrix: ",identifiability_modules)
    for x in range(len(identifiability_modules)):
        for y in range(len(identifiability_modules[0])):
            if(identifiability_modules[x][y]==1):
                nodefrom = y + 1
                nodeto = x + 1
                #check which transfer is measurable
                #print("module is 1 and trying to set the number of nodes for From: ",nodefrom," To: ",nodeto)
                for f in range(number_of_nodes):
                    if(btnStore[f]!=0):
                        if(btnStore[f][4]==nodeto and btnStore[f][5]==nodefrom):
                            #check which btn it is corresonding to
                            #print("setting tranfer to known after identifiability check")
                            draw.itemconfig(btnStore[f][0],fill="green")
                            btnStore[f][1].known = 1
                            #set the transfer to known


# Load mat will move everything in from the specific mat file.
def loadMat(draw,master):
    print("starting to loadMat")
    global connect
    global lineNumber
    global lineStore
    global outputStore
    global storeNG
    global storeNR
    global storeNH
    global nodeSize
    global currentView
    #make sure that currentview is in abstract modus
    currentView = 0
    #ask for a file name
    print("trying to ask for file name")
    filename = askopenfilename()
    #read the file
    storeNG, storeNR, storeNH = readFile(filename)
    #sent the information to abstractPlot
    abstractPlot(draw,master,storeNG,storeNR,storeNH)
    nodeSize = -(10/110)*(len(storeNG)**1.8)+26
    if(nodeSize<5):
        nodeSize=5

    textSize = round(nodeSize/2*unit.currentZoom)
    if(textSize<1):
        textSize = 1
    unit.textSize = textSize


def plotNoise(draw,master):
    global overlay
    global lineNumber
    global lineStore
    global outputStore
    global outputNumber
    global Unknownnodes
    global excitationNumber
    global storeNG
    global storeNH
    global storeNR

    #set the view to be detailed:
    if(currentView==0):
        switchView(draw,master)
    NG, NR, NH, Unknownnodes = toAdjacencyMatrix(draw,master)
    clearWindow(draw,0)
    overlay = 1

    amountNodes = len(NG)
    nmbNoise = len(NH[0])
    excitationNumber = len(NR)

    #get the coordinates of the node
    pos = generateGraph(NG,NR,NH,1,500*unit.currentZoom, layoutMethod)
    plotNoise = nx.DiGraph()
    plotNoise.add_nodes_from(pos.keys())
    for n in range(amountNodes):
        plotNoise.nodes[n]['pos'] = pos[n]

    nmbOutputs = len(NH)
    nmbOutputs2 = len(NH[0])
    #create nx matrix for the noise
    plotNoise.add_nodes_from(range(amountNodes,amountNodes+nmbOutputs))
    for x in range(nmbOutputs):
        for y in range(len(NH[x])):
            if(NH[x][y] == 1):
                #print("added edge from y: ",y+amountNodes," to x: ",x, " for: ", NH[x][y])
                plotNoise.add_edge(y+amountNodes,x)
    #obtain position for the noise view nodes
    posNoise = nx.spring_layout(plotNoise, scale=500*unit.currentZoom, center=(500,500))
    #print(posNoise)


    #below function will read through the mat file and try to find how many modules their are
    #plot each function in a circle

    for x in range(amountNodes):
        addOutput(draw, pos[x][0], pos[x][1],master)

    for x in range(amountNodes):
        for y in range(amountNodes):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,0)


    for x in range(nmbOutputs2):
        addNoiseNode(draw, posNoise[x+amountNodes][0], posNoise[x+amountNodes][1],master)

    for x in range(nmbOutputs):
        for y in range(nmbOutputs2):
            if(NH[x][y]==1):
                node1 = noiseNodeStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)
    storeNR = NR
    storeNH = NH
    storeNG = NG

    #this function is called to load the plotMatrix from the global known Matrix
def plotMatrix(draw,master,init):
    global overlay
    global storeNH
    global storeNG
    global storeNR
    global Makeknown
    global outputStore
    global outputNumber
    global excitationNumber

    #switch to detailed
    if(currentView==0):
        switchView(draw,master)
        overlay = 0
        return

    #for init use the stored values else temp save the required values and clear the screen
    if(init):
        NG = storeNG
        NR = storeNR
        NH = storeNH
    else:
        NG, NR, NH, Unknownnodes = toAdjacencyMatrix(draw,master)
        clearWindow(draw,0)
        excitationNumber = 0
        #store noise so that the Adjacency function can pick it from global variables
        storeNH = NH
        storeNG = NG
        storeNR = NR

    overlay = 0

    global lineNumber
    global lineStore

    nmbOutputs = len(NG)

    #send the data to networkx to generate positions on the screen
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom,layoutMethod)

    for x in range(nmbOutputs):
        addOutput(draw, pos[x][0], pos[x][1],master)

    #make all the connectiosn tussen connectOutputs
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                node1 = outputStore[y]
                node2 = outputStore[x]
                connectOutputs(node1,node2,draw,master,1)

    #this is a priority to put the circle and text aboven the lines
    for x in range(len(NH)):
        for y in range(len(NH[x])):
            if(NH[x][y]==1):
                addNH(outputStore[x],master,draw,0,y)
    for x in range(len(NR)):
        for y in range(len(NR[x])):
            if(NR[x][y]==1):
                addNH(outputStore[x],master,draw,1,y)

    draw.tag_raise("nodes")
    draw.tag_raise("rect")
    draw.tag_raise("wNotation")

    #connecting each output is below


    #this functions read the current Storage variables to then return everything in a matrix so that it can be saveds
def toAdjacencyMatrix(draw,master):
    global storeNG
    global storeNH
    global storeNR
    global butTestStore
    global outputNumber
    global outputStore
    global Unknownnodes
    #this simply is a really large call so that the entire function can be in a different file and that DeliveryDemo.py maintains some smaller size
    storeNG, storeNR, storeNH, outputNumber, outputStore, Unknownnodes= toAdjacencyMatrixCall(draw,master,overlay,storeNG,storeNH,storeNR,lineStore,lineNumber,outputStore,outputNumber,excitationStore,excitationNumber,noiseNodeStore,noiseNodeNumber, Unknownnodes, noiseNumber)

    return storeNG, storeNR, storeNH, Unknownnodes

def abstractPlot(draw,master,NG,NR,NH):
    global butTestStore
    global butTestNumber
    #generate the positions
    pos = generateGraph(NG,NR,NH,3,500*unit.currentZoom, layoutMethod)
    nmbOutputs = len(NG)

    #make all the connection between nodes
    for x in range(nmbOutputs):
        for y in range(nmbOutputs):
            if(NG[x][y]==1):
                #first draw the lines
                draw.create_line(pos[x][0], pos[x][1], pos[y][0], pos[y][1])

    for x in range(nmbOutputs):
        #draw each node
        widget = draw.create_circle(pos[x][0], pos[x][1], 5*unit.currentZoom, fill="red")

def switchView(draw, master):
    global storeNG
    global storeNR
    global storeNH
    global currentView
    global overlay

    #switch between abstract view and more complex view speaks for itself.
    if(overlay==0):
        if(currentView == 0):
            currentView = 1
            print("changing to detail")
            draw.delete("all")
            plotMatrix(draw,master,1)

        else:
            if(currentView == 1):
                toAdjacencyMatrix(draw,master)
                NG = storeNG
                NR = storeNR
                NH = storeNH
                print("changing to abstract")
                clearWindow(draw,0)
                abstractPlot(draw,master,NG,NR,NH)
                storeNG = NG
                storeNR = NR
                storeNH = NH

                currentView = 0

#this is the callback function for when the dropbox of views is changed and the corresponding view is here updated
def viewCall(*args):
    print("Updating view!")
    currentMode = viewMethod.get()
    print(currentMode)
    if(currentMode=="Detail view"):
        plotMatrix(draw,master,0)
        print("test")
    elif(currentMode=="Noise view"):
        plotNoise(draw,master)
    elif(currentMode=="Abstract view"):
        #if in noise mode first go to detail view and the change to abstract
        if(overlay==1):
            plotMatrix(draw,master,0)
        switchView(draw,master)


"""
Below we have the subsection of:

-------------------------------------------------------- nodes --------------------------------------------------------

Each function uses the global variables to store the nodes and to make changes
"""
# adding a node

    #addNode takes as argument firstly the draw variable and coordinates and then adds a node for the transfers
def addNode(w,x,y,master,node1,node2):
        global number_of_nodes
        global btnStore
        global outputStore
        global outputNumber
        global overlay
        node = 0
        textSize = round(nodeSize/2*unit.currentZoom)
        if(textSize<1):
            textSize = 1

        height = nodeSize*unit.currentZoom*0.8
        width = nodeSize*unit.currentZoom

        #check if it should plot transfer for noise or for normal
        node_name = "G"
        if(overlay):
            node_name = "H"

        #creating node x
        number_1 = 0
        number_2 = 0
        for a in range(outputNumber):
            if(outputStore[a]==node1):
                number_1 = node1[1].nmb
            if(outputStore[a]==node2):
                number_2 = node2[1].nmb
        for a in range(noiseNodeNumber):
            if(noiseNodeStore[a]==node1):
                number_1 = node1[1].nmb
        #perform initial node
        pixelVirtual = PhotoImage(width=3,height=1)
        if(number_of_nodes==0):
            btn = nodeHolder()
            btn.stat = 1
            btn.known = 0
            btn.pms = 0
            btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
            btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
            save = [btn.id,btn,x,y,number_1,number_2]
            #append it on th end
            btnStore.append(save)
            number_of_nodes = number_of_nodes + 1
            #print("start initial node")

        else:
            #first search if a entry is zero because then a node has been removed their and we can insert a new one
            for m in range(number_of_nodes-1):
                if(btnStore[m]==0):
                    btn = nodeHolder()
                    btn.stat = 1
                    btn.known = 0
                    btn.pms = 0
                    btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                    btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                    save = [btn.id,btn,x,y,number_1,number_2]
                    btnStore[m] = save
                    #print("added node in existing place")

            #if no space is free and it is not the initial node append a new one on the end.
            if(number_of_nodes!=0 and node == 0):
                btn = nodeHolder()
                btn.stat = 1
                btn.known = 0
                btn.pms = 0
                btn.id = w.create_rectangle(x-width,y-height,x+width,y+height,fill="cyan",tags="rect")
                btn.text = w.create_text(x,y,text=str(node_name)+str(number_2)+","+str(number_1),width=0, font=("Courier", textSize),tags="wNotation")
                save = [btn.id,btn,x,y,number_1,number_2]
                btnStore.append(save)
                number_of_nodes = number_of_nodes + 1
                #print("appended node to back of list")

        #print(btnStore)

def removeNode(w, master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber

    number_of_nodes, btnStore, lineStore, lineNumber = removeNodeCall(draw,master,number_of_nodes,btnStore,lineStore,lineNumber)

"""
below are the functions regarding

-------------------------------------------------------- noise and excitation--------------------------------------------------------

important note! these functions are a bit rewritten to allow both external signals and noise manipulations. NorH = 0 is noise and NorH = 1 is excitation. Because if(var) is true if
var = 1 it becomes that if(NorH) is true when we add a excitation signal. We use this to make the below function availible for both signals. first we load in noise because it is most used
and therefor the fastes one and change it if needed for excitation
"""


    #this function takes as most important NorH and then plots the corresponding marker on a node. N is Noise and H is excitation. it will ask which source it should have
def addNHCall(master, draw,NorH):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global clickOperation

    if(overlay==0):
        #ask which noise or excitation source it belongs to
        call = popupWindow(master)
        master.wait_window(call.top)
        node = 0
        nmb = call.value
    #find output which is selected and save it to node

        for x in range(outputNumber):
            #print(outputStore[x])
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    addNH(node,master,draw,NorH,nmb)

    else:
        clickOperation=3

    #Add the final noise or excitation marker
def addNH(node,master,draw,NorH,nmb):
    global outputStore
    global outputNumber
    global noiseNumber
    global noiseStore
    global excitationStore
    global excitationNumber
    global storeNH
    global storeNR
    switch = 0
    width = nodeSize*unit.currentZoom*1.6
    heigth = nodeSize*unit.currentZoom*1.6
    #print("NorH: ",NorH)
    #move the x y to left above the center of the output
    x,y = trueCoordinates(draw,node)
    marker = nodeHolder()
    marker.nmb = nmb
    textSize = round(nodeSize/2*unit.currentZoom)
    if(textSize<1):
        textSize = 1

    if(NorH==0):
        marker.arc = draw.create_arc(x,y,x+width,y-heigth,fill="yellow")
        marker.text = draw.create_text(x+width*(11/16), y-heigth*(11/16), text="V",width=0, font=("Courier", textSize),tags="wNotation")
    else:
        marker.arc = draw.create_arc(x,y,x-width,y-heigth,fill="green",start=90)
        marker.text = draw.create_text(x-width*(11/16), y-heigth*(11/16), text="R",width=0, font=("Courier", textSize),tags="wNotation")
    marker.stat = 1
    save = [marker.arc,marker,x,y,node[1]]

    #store noise in a open spot
    if(node!=0):
        if(NorH):
            for x in range(excitationNumber):
                if(excitationStore[x]==0 and switch==0):
                    excitationStore.insert(x,save)
                    switch = 1
        else:
            for x in range(noiseNumber):
                if(noiseStore[x]==0 and switch==0):
                    noiseStore.insert(x,save)
                    switch = 1

        #if no open space left append it on the end
        if(switch==0):
            if(NorH):
                excitationStore.append(save)
                excitationNumber = excitationNumber + 1
            else:
                noiseStore.append(save)
                noiseNumber = noiseNumber + 1
            #print("noise or excitation added! number: ",noise)
            #change the store NH or NR
        for x in range(outputNumber):
            if(outputStore[x]==node):
                temp = copy.deepcopy(x)
        if(NorH):
            storeNR[temp][int(nmb)] = 1
        else:
            storeNH[temp][int(nmb)] = 1
    #as said it searches the active node and removes either the excitation or noise
def removeNH(draw, master, NorH):
    global noiseStore
    global noiseNumber
    global outputStore
    global outputNumber
    global excitationNumber
    global excitationStore
    global storeNH
    global storeNR

    if(overlay==1):
        removeNoise()
    else:
        node = 0

        #print("trying to remove the noise")

        #find selected output
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat == 2):
                    node = outputStore[x]
                    temp = copy.deepcopy(x)
                    #print("found output: ",node)

        #search for noise entry which has the selected output
        if(NorH):
            for x in range(excitationNumber):
                #print("scanning: ",excitationStore[x])
                if(excitationStore[x]!=0):
                    if(excitationStore[x][4] == node[1]):
                        #remove it
                        draw.delete(excitationStore[x][1].text)
                        draw.delete(excitationStore[x][0])
                        excitationStore[x] = 0
                        if(x == excitationNumber):
                            excitationNumber = excitationNumber - 1
                        storeNR[temp][x] = 0
        else:
            for x in range(noiseNumber):
                #print("scanning: ",noiseNodeStore[x])
                if(noiseStore[x]!=0):
                    if(noiseStore[x][4] == node[1]):
                        #remove it
                        temp2 = noiseStore[x][1].nmb
                        draw.delete(noiseStore[x][1].text)
                        draw.delete(noiseStore[x][0])
                        noiseStore[x] = 0
                        if(x == noiseNumber):
                            noiseNumber = noiseNumber - 1
                        storeNH[temp][temp2] = 0



"""
Below are the functions for

-------------------------------------------------------- noise Node --------------------------------------------------------

tada
"""

    #ass the noiseNode for the noise Overview
def addNoiseNode(draw,x,y,master):
    global noiseNodeNumber
    global noiseNodeStore

    img1Btn = nodeHolder()
    noiseNodeNumber, noiseNodeStore = addNoiseNodeCall(draw,x,y,master,noiseNodeNumber,noiseNodeStore, img1Btn,unit, nodeSize)

    #ass the noiseNode for the noise Overview sets a specific node to the select conditions
def selectNoiseNode(node):
    global currentAmountOutputSelected

    currentAmountOutputSelected = selectNoiseNodeCall(draw,master,noiseNodeNumber,noiseNodeStore, currentAmountOutputSelected, node,lineNumber,lineStore)

    #removes the noise in the noiseOverview when selected
def removeNoise():
    global noiseNodeStore
    global lineStore
    global noiseNodeNumber
    global number_of_nodes
    global btnStore
    for y in range(noiseNodeNumber):
        if(noiseNodeStore[y]!=0):
            if(noiseNodeStore[y][1].stat == 2):
                temp = noiseNodeStore[y][1].nmb
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][4] == temp or btnStore[x][5] == temp):
                btnStore[x][1].stat = 2
    noiseNodeStore, lineStore, noiseNodeNumber = removeNoiseNodeCall(noiseNodeStore, noiseNodeNumber, lineStore, lineNumber, draw)
    removeNode(draw, master)

"""
Below are the functions for

-------------------------------------------------------- output --------------------------------------------------------

tada
"""

#Below are some functions to make tedious task a bit easier
def returnSelectedNodes():
    nodeList = []
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2):
                nodeList.append(outputStore[x])
    return nodeList

    #returns list of node in selected groupNumber
def returnGroupList(groupNumber):
    nodeList = []
    for x in outputStore:
        if(x[1].group == groupNumber or x[1].group == 3):
            nodeList.append(x)

    return nodeList

    #saves nodes from a list
def saveSelectedNodes(nodeList):
    global outputStore

    for x in nodeList:
        outputStore[x[1].nmb-1] = x

    #puts all active nodes to none active
def deselectActiveNodes():
    nodeList = returnSelectedNodes()
    for x in nodeList:
        selectOutput(x[1].nmb-1,draw)


    #finds the path from one point to another along the shortest path using the nx library
def find_path(draw,master):
    global newPathColor
    global storeNG
    global storeNR
    global storeNH
    global Unknownnodes
    storeNG, storeNR, storeNH, Unknownnodes = toAdjacencyMatrix(draw,master)
    #putting all selected nodes in a list
    nodeSearchList = returnSelectedNodes()

    if(nodeSearchList[0][1].order>nodeSearchList[1][1].order):
        temp = nodeSearchList[0]
        nodeSearchList[0] = nodeSearchList[1]
        nodeSearchList[1] = temp

    #adding them to a networkx to scan for the shortest route because networkx is lit
    path = graphShortestPath(storeNG,nodeSearchList)
    print("calculated path:",path)
    dis = len(path)-1
    print(dis)
    i = 0
    while(i<dis):
        for x in range(lineNumber):
            if(lineStore[x]!=0):
                #print("current i loop: ",i)
                if(lineStore[x][1].nmb == path[i]+1 and lineStore[x][2].nmb == path[i+1]+1):
                    draw.itemconfig(lineStore[x][0],fill=fancyColor[newPathColor])
                    draw.itemconfig(lineStore[x][0],width=5)
                    lineStore[x][4] = fancyColor[newPathColor]
                    #print("painted the path to goal")
        i += 1
    newPathColor += 1
    deselectActiveNodes()

    #search the disjoint path for a group of nodes
def paint_disjoint_path(draw,master):
    global newPathColor
    global storeNG
    global storeNR
    global storeNH
    global Unknownnodes
    storeNG, storeNR, storeNH, Unknownnodes = toAdjacencyMatrix(draw,master)
    #putting all selected nodes in a list
    group1 = returnGroupList(1)
    group2 = returnGroupList(2)

    #adding them to a networkx to scan for the shortest route because networkx is lit
    path = graphDisjointPath(storeNG, group1, group2,1)
    disconnected_set = graphDisjointPath(storeNG, group1, group2,0)
    print("found disconnected set", disconnected_set)
    print("found disjoint path:", path)
    cyclePath = len(path)
    for f in range(cyclePath):
        dis = len(path[f])-1
        i = 0
        while(i<dis):
            for x in range(lineNumber):
                if(lineStore[x]!=0):
                    #we loop here through the list of all path and set each variable to a original color
                    if(lineStore[x][1].nmb == path[f][i]+1 and lineStore[x][2].nmb == path[f][i+1]+1):
                        draw.itemconfig(lineStore[x][0],fill=fancyColor[newPathColor])
                        draw.itemconfig(lineStore[x][0],width=5)
                        if(lineStore[x][5]=="arrow"):
                            draw.itemconfig(lineStore[x][0],width=10)
                        lineStore[x][4] = fancyColor[newPathColor]
                        #print("painted the path to goal")
            i += 1
        newPathColor += 1

    for x in disconnected_set:
        if(outputStore[x]!=0):
            draw.itemconfig(outputStore[x][0],fill="purple")

    deselectActiveNodes()

    #Create the minimum tree case
def draw_tree(draw,master):
    global treeStore
    toAdjacencyMatrix(draw,master)
    treeStore = []
    i=10
    for x in outputStore:
        if x!=0:
            draw.itemconfig(x[0],fill=fancyColor[i])
            lineDrawer = []
            for y in lineStore:
                if y!=[] and y!=0:
                    if y[1] == x[1] and y[5]=="line":
                        print("found line:",y[0],",",y[1].nmb,",",y[2].nmb,"for node",x[1].nmb)
                        draw.itemconfig(y[0],fill=fancyColor[i])
                        for f in btnStore:
                            if f[1] == y[3]:
                                draw.itemconfig(f[0],fill=fancyColor[i])
                        lineDrawer.append(y)

            drawer = [i,x[1],[],lineDrawer,[]]
            #drawer looks like this drawer = [colorID,rootNode, passingNodes,linesInTree]
            treeStore.append(drawer)
            i += 5
    #print("current generated treeStore:",treeStore)

    #tries to do all the merging so that we can create the maximum tree
def find_maximum_tree(draw,master):
    global treeStore
    stat = 1
    while stat == 1:
        mergeMatrix = treeAllocation(treeStore)
        masterTree = 0
        found = 0
        for x in mergeMatrix:
            slaveTree = 0
            for y in x:
                if y == 1 and found == 0:
                    #print("performed merge for:",masterTree,",",slaveTree)
                    combindedTree = mergeTree(treeStore[masterTree],treeStore[slaveTree])
                    #print(combindedTree)
                    for x in outputStore:
                        if x!=0:
                            if x[1] == combindedTree[1]:
                                #print("tried colloring the nodes:",x)
                                draw.itemconfig(x[0],fill=fancyColor[combindedTree[0]])
                            for y in combindedTree[2]:
                                if x[1] == y:
                                    #print("tried colloring the nodes:",x)
                                    draw.itemconfig(x[0],fill=fancyColor[combindedTree[0]])

                    for x in combindedTree[3]:
                        draw.itemconfig(x[0],fill=fancyColor[combindedTree[0]])
                        for f in btnStore:
                            if f[1] == x[3]:
                                draw.itemconfig(f[0],fill=fancyColor[combindedTree[0]])
                    treeStore[masterTree] = combindedTree
                    treeStore.pop(slaveTree)
                    found = 1
                slaveTree += 1
            masterTree+=1
        if found == 0:
            stat = 0

    #sets a set of nodes to a group
def makeGroup(draw,master):
    global currentGroup
    print("setting the currentGroup: ", currentGroup)
    groupList = returnSelectedNodes()
    for x in groupList:
        x[1].group += currentGroup
        x[4] = fancyColor[currentGroup]

    saveSelectedNodes(groupList)
    currentGroup += 1
    deselectActiveNodes()

    #removes all current groups
def removeGroup(draw,master):
    global outputStore
    global currentGroup
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].group != 0):
                outputStore[x][1].group = 0
                outputStore[x][4] = "red"
                draw.itemconfig(outputStore[x][0],fill="red")
    currentGroup = 1

    #adds a node (here called output)
def addOutput(draw, x, y, master):
        global outputStore
        global outputNumber
        global storeNR
        #create output
        switch = 0
        node = 0
        size = nodeSize
        #print("current size: ",size)
        #set img1btn as object so that we can add .widget containing the circle id.
        img1Btn = nodeHolder()
        img1Btn.widget = draw.create_circle(x,y,size*unit.currentZoom, fill="red", tags="nodes")
        img1Btn.nmb = 0
        img1Btn.stat = 1
        img1Btn.zoom = size*unit.currentZoom
        textSize = round((size/2)*unit.currentZoom)
        img1Btn.nodeMode = []
        if(textSize<1):
            textSize = 1

        for i in range(5):
            img1Btn.nodeMode.append(IntVar())

        #use same save technique so that all the functions remain functional
        save = [img1Btn.widget,img1Btn,x,y,"red"]

        #earch if their is a empty entry.
        for m in range(outputNumber):
            if(outputStore[m]==0):
                img1Btn.nmb=m+1
                nmb = draw.create_text(x, y, text="W"+str(m+1),width=0, font=("Courier", textSize),tags="wNotation")
                save.append(nmb)
                outputStore[m] = save
                switch = 1

                #initial output
        if(outputNumber==0):
            img1Btn.nmb=1
            nmb = draw.create_text(x, y, text="W"+str(1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1
            switch = 1

        #append if no empty entry
        if(switch==0):
            img1Btn.nmb=outputNumber+1
            nmb = draw.create_text(x, y, text="W"+str(outputNumber+1),width=0, font=("Courier", textSize),tags="wNotation")
            save.append(nmb)
            outputStore.append(save)
            outputNumber = outputNumber + 1


    #removes a node (here called output)
def removeOutput(draw,master):
    global outputStore
    global outputNumber
    #search for output and set it to 0
    removeNH(draw,master,0)
    removeNH(draw,master,1)

    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat == 2):
                for i in range(lineNumber):
                    #print("i: ",i," lineStore:",lineStore[i],"")
                    if(lineStore[i]!=0):
                        if(lineStore[i][1]==outputStore[x][1] or lineStore[i][2]==outputStore[x][1]):
                            #print("i: ",i," is deleted")
                            lineStore[i][1].stat == 2
                            draw.delete(lineStore[i][0])
                            removeNode(draw, master)
                            lineStore[i]=0
                draw.delete(outputStore[x][5])
                draw.delete(outputStore[x][0])
                outputStore[x] = 0

    #changes the appearance of a node based on if it is selected
def selectOutput(f,draw):
    global currentAmountOutputSelected
    global lineNumber
    global outputStore
    global lineNumber
    id = outputStore[f][1]
    #each output has a stat variable which indicates state. stat == 1 is not selected, stat == 2 is selected. stat == 4 is unknown node
    if(outputStore[f][1].stat==1):
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        outputStore[f][1].stat = 2
        draw.itemconfig(outputStore[f][0],fill="pink")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill="red")
    elif(outputStore[f][1].stat==2):
        id.order = 0
        currentAmountOutputSelected = currentAmountOutputSelected - 1
        outputStore[f][1].stat = 1
        draw.itemconfig(outputStore[f][0],fill=outputStore[f][4])
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])

    elif(outputStore[f][1].stat==3):
        id.order = currentAmountOutputSelected
        currentAmountOutputSelected = currentAmountOutputSelected + 1
        outputStore[f][1].stat = 4
        draw.itemconfig(outputStore[f][0],fill="pink")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill="red")
    else:
        id.order = 0
        currentAmountOutputSelected = currentAmountOutputSelected - 1
        outputStore[f][1].stat = 3
        draw.itemconfig(outputStore[f][0],fill="blue")
        #print("buttond found!")
        for a in range(lineNumber):
            if(lineStore[a]!=0):
                if (id==lineStore[a][1] or id==lineStore[a][2]):
                    draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])

    #make a specific node known or unknown
def makeunknown(master, draw):
    global currentAmountOutputSelected
    global outputStore
    global outputNumber
    global lineStore
    global lineNumber
    global unknownNodenumber
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2):
                outputStore[x][1].stat = 4
                selectOutput(x,draw)
                unknownNodenumber +=1
            elif(outputStore[x][1].stat==4):
                outputStore[x][1].stat = 2
                selectOutput(x,draw)
                unknownNodenumber -=1
    reloadCall(subMenu,reload,currentAmountOutputSelected,0)

"""
below are the functions for

-------------------------------------------------------- PMS --------------------------------------------------------
"""

def USC(master,draw):
    global outputStore
    global currentAmountOutputSelected
    global number_of_nodes
    global lineNumber
    global lineStore
    global btnStore
    global unknownNodenumber
    global outputNumber
    global NG_pms
    global NR_pms
    global NH_pms
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    i = 0
    j = 0
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    if(i==j==0):
        msg = "No target module selected"
        popupmsg(msg)
        return 0,0,0,0,False
    #look for accessible nodes
    accessible = (np.zeros(len(NG_pms))).tolist()
    for x in range(outputNumber):
        if(outputStore[x]!=0):
            if(outputStore[x][1].stat==2 or outputStore[x][1].stat==4):
                accessible[x] = 1
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    Q = (np.zeros(len(NG_pms))).tolist()
    Beta = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
        #find in-neighbours of Y
    inneighbours = []
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            for y in range(outputNumber):
                if(outputStore[y][1].nmb-1==x):
                    inneighbours.append(outputStore[y])
    #find out-neighbours of D
    outneighbours = []
    for x in range(len(NG_pms)):
        if(NG_pms[x][i]):
            for y in range(outputNumber):
                if(outputStore[y][1].nmb-1==x):
                    outneighbours.append(outputStore[y])
    #find disconnecting set
    NG = copy.deepcopy(NG_pms)
    disconnected_set = graphDisjointPath(NG, outneighbours, inneighbours,0)
    for x in range(len(disconnected_set)):
        temp = disconnected_set[x]
        if(accessible[temp]):
            D[temp] = 1
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)
    change = 1
    while(change):
        #all accessible inneighbours of Y
        for x in range(len(NG_pms)):
            if(NG_pms[j][x] and accessible[x]):
                D[x] = 1
        #all accessible through inaccessible path
        Unknownnodes_usc = []
        unknownNodenumber = 0
        for x in range(len(accessible)):
            if(accessible[x]):
                Unknownnodes_usc.append(0)
            else:
                Unknownnodes_usc.append(1)
                unknownNodenumber +=1
        print(str(Unknownnodes_usc))
        G, B, R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
        for x in range(len(G)):
            if(G[j][x]):
                D[x] = 1
        #direct confounding or indirect confounding through inaccessible
            #direct
        for y in range(len(Y)):
            if(Y[y]):
                for x in range(len(NH_pms)):
                    if(NH_pms[y][x]):
                        for r in range(len(NH_pms)):
                            if(NH_pms[r][x] and NG_pms[y][r] and accessible[r]):
                                Y[r] = 1
                                Q[r] = 1
            #indirect
        unknownNodenumber = 0
        Unknownnodes_usc = []
        for x in range(len(accessible)):
            if(accessible[x]):
                Unknownnodes_usc.append(0)
            else:
                Unknownnodes_usc.append(1)
                unknownNodenumber =+1
        NG = copy.deepcopy(NG_pms)
        NH = copy.deepcopy(NH_pms)
        NR = copy.deepcopy(NR_pms)
        G, B, R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
        for y in range(len(Y)):
            if(Y[y]):
                for x in range(len(B)):
                    if(NH_pms[y][x]):
                        for r in range(len(B)):
                            if(B[r][x] and G[y][r] and accessible[r]):
                                Y[r] = 1
                                Q[r] = 1
        #include signals from D into A
        #no confounding variables case
        A_direct = copy.deepcopy(D)
        for y in range(len(Y)):
            if(Y[y]):
                for x in range(len(B)):
                    if(B[y][x]):
                        for r in range(len(B)):
                            if(B[r][x] and G[y][r] and accessible[r]):
                                A_direct[r] = 0
        #indirect confounding through accessible
        A_indirect = []
        for x in range(len(D)):
            if(D[x] and Y[x]==0 and A_direct[x]==0):
                A_indirect.append(1)
            else:
                A_indirect.append(0)

        for x in range(len(A_indirect)):
            if(A_indirect[x]):
                A_indirect[x] = 0
                Unknownnodes_usc = (np.ones(len(D))).tolist()
                unknownNodenumber = len(D)
                Unknownnodes_usc[x] = 0
                unknownNodenumber -= 1
                for j in range(len(Y)):
                    if(Y[j]):
                        Unknownnodes_usc[j] = 0
                        unknownNodenumber -= 1
                NG = copy.deepcopy(NG_pms)
                NH = copy.deepcopy(NH_pms)
                NR = copy.deepcopy(NR_pms)
                G, B, R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
                for y in range(len(B)):
                    if(Y[y]):
                        for r in range(len(B)):
                            if(B[y][r] and B[x][r] and G[y][x]):
                                NG = copy.deepcopy(NG_pms)
                                nodeSearchList = [outputStore[x],outputStore[y]]
                                list = graphShortestPath(NG,nodeSearchList)
                                #checking if it goes through an inaccessible node
                                A_indirect[x] = 1
                                for alpha in range(len(list)):
                                    if(accessible[int(list[alpha])]==0):
                                        A_indirect[x] = 0
        #combining the two cases
        A = []
        for x in range(len(A_direct)):
            if(A_direct[x] or A_indirect[x]):
                A.append(1)
            else:
                A.append(0)
        #step 7
        change = 0
        unknownNodenumber = 0
        Unknownnodes_usc = []
        for x in range(len(accessible)):
            if(accessible[x]):
                Unknownnodes_usc.append(0)
            else:
                Unknownnodes_usc.append(1)
                unknownNodenumber =+1
        NG = copy.deepcopy(NG_pms)
        NH = copy.deepcopy(NH_pms)
        NR = copy.deepcopy(NR_pms)
        G, B, R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
        for x in range(len(B)):
            for y in range(len(B)):
                if(Y[x] and D[y] and Y[y]==0):
                    for r in range(len(B)):
                        if(B[x][r] and B[y][r] and G[x][y]):
                            Beta[y] = 1
                            if(Theorem1(master,draw,Beta,A,Y,D,accessible)==False):
                                Beta[y] = 0
                                Y[y] = 1
                                Q[y] = 1
                                change = 1
    #step 8
    for x in range(len(A)):
        if(A_indirect[x]):
            #first option
            A[x] = 0
            Beta[x] = 1
            if(Theorem1(master,draw,Beta,A,Y,D,accessible)):
                p = 1
            #second option
            else:
                A[x] = 1
                Beta[x] = 0
                Unknownnodes_usc = (np.ones(len(D))).tolist()
                unknownNodenumber = len(D)
                Unknownnodes_usc[x] = 0
                unknownNodenumber -= 1
                for j in range(len(accessible)):
                    if(accessible[j]):
                        Unknownnodes_usc[j] = 0
                        unknownNodenumber -= 1
                NG = copy.deepcopy(NG_pms)
                NH = copy.deepcopy(NH_pms)
                NR = copy.deepcopy(NR_pms)
                G, B, R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
                D_fic, Y_fic, A_fic, Blocking_fic = FIC(master,draw,G,R,B)
                Beta_option_2 = copy.deepcopy(Beta)
                for y in range(Blocking_fic):
                    if(Blocking_fic[y]):
                        Beta_option_2[y] = 1
                if(Theorem1(master,draw,Beta_option_2,A,Y,D,accessible)):
                    Beta = Beta_option_2
            #third option
                else:
                    A[x] = 0
                    Y[x] = 1
                    Q[x] = 1
    #select the nodes in D and Y
    for f in range(len(D)):
        id = outputStore[f][1]
        if(D[f] or Y[f]):
            draw.itemconfig(outputStore[f][0],fill="yellow")
        if(outputStore[f][1].stat==2):
            id.order = 0
            currentAmountOutputSelected = currentAmountOutputSelected - 1
            outputStore[f][1].stat = 1
            for a in range(lineNumber):
                if(lineStore[a]!=0):
                    if (id==lineStore[a][1] or id==lineStore[a][2]):
                        draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])
        elif(outputStore[f][1].stat==4):
            id.order = 0
            currentAmountOutputSelected = currentAmountOutputSelected - 1
            outputStore[f][1].stat = 3
            for a in range(lineNumber):
                if(lineStore[a]!=0):
                    if (id==lineStore[a][1] or id==lineStore[a][2]):
                        draw.itemconfig(lineStore[a][0], fill=lineStore[a][4])
    #create the output message
    msg = "Inputs:"
    for x in range(len(D)):
        if(D[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nOutputs:"
    for x in range(len(Y)):
        if(Y[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nA:"
    for x in range(len(A)):
        if(A[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nB:"
    for x in range(len(Beta)):
        if(Beta[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    popupmsg(msg)



def Theorem1(master,draw,Beta,A,Y,D,accessible):
    global NG_pms
    global NR_pms
    global NH_pms
    global unknownNodenumber
    condition2a = 1
    condition2c = 1
    #condition 2a
        #A and Y
    Unknownnodes_usc = (np.ones(len(Y))).tolist()
    unknownNodenumber = len(Y)
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)
    for a in range(len(NG)):
        if(Y[a] or A[a]):
            unknownNodenumber -=1
            Unknownnodes_usc[a] = 0
    Im_G, Im_B, Im_R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
    for a in range(len(NG)):
        for b in range(len(NG)):
            if(Y[a] and A[b]):
                for c in range(len(NG)):
                    if(Im_B[a][c] and Im_B[b][c]):
                        condition2a = 0
        #A and B
    Unknownnodes_usc = (np.ones(len(Y))).tolist()
    unknownNodenumber = len(Y)
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)
    for a in range(len(NG)):
        if(Beta[a] or A[a]):
            unknownNodenumber -=1
            Unknownnodes_usc[a] = 0
    Im_G, Im_B, Im_R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
    for a in range(len(NG)):
        for b in range(len(NG)):
            if(Beta[a] and A[b]):
                for c in range(len(NG)):
                    if(Im_B[a][c] and Im_B[b][c]):
                        condition2a = 0
    #condition 2c
    for y in range(len(Beta)):
        if(Beta[y]):
            Unknownnodes_usc = (np.ones(len(Y))).tolist()
            unknownNodenumber = len(Y)
            NG = copy.deepcopy(NG_pms)
            NH = copy.deepcopy(NH_pms)
            NR = copy.deepcopy(NR_pms)
            for a in range(len(NG)):
                if(accessible[a]):
                    unknownNodenumber -=1
                    Unknownnodes_usc[a] = 0
                    NG[y][a] = 0
            Im_G, Im_B, Im_R = Immersion(NG,NR,NH,Unknownnodes_usc,draw,master)
            for a in range(len(NG)):
                if((Y[a] or D[a]) and Im_G[y][a]):
                    condition2c = 0

    if(condition2a==0 or 0==condition2c):
        return False
    else:
        return True

def MIC(master,draw):
    global outputStore
    global number_of_nodes
    global lineNumber
    global lineStore
    global btnStore
    global outputNumber
    global NG_pms
    global NR_pms
    global NH_pms
    global currentAmountOutputSelected
    NG_pms, NR_pms, NH_pms, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    #look for the button
    i = 0
    j = 0
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    if(i==j==0):
        msg = "No target module selected"
        popupmsg(msg)
        return
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    #find in-neighbours of Y
    inneighbours = []
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            for y in range(outputNumber):
                if(outputStore[y][1].nmb-1==x):
                    inneighbours.append(outputStore[y])
    #find out-neighbours of D
    outneighbours = []
    for x in range(len(NG_pms)):
        if(NG_pms[x][i]):
            for y in range(outputNumber):
                if(outputStore[y][1].nmb-1==x):
                    outneighbours.append(outputStore[y])
    #find disconnecting set
    NG = copy.deepcopy(NG_pms)
    disconnected_set = graphDisjointPath(NG, outneighbours, inneighbours,0)
    for x in range(len(disconnected_set)):
        temp = disconnected_set[x]
        D[temp] = 1
    NG = copy.deepcopy(NG_pms)
    NH = copy.deepcopy(NH_pms)
    NR = copy.deepcopy(NR_pms)

    #step node signal
    Q = (np.zeros(len(NG_pms))).tolist()
    change = 1
    while(change):
        change = 0
        for y in range(len(Y)):
            if(Y[y]):
                for x in range(len(NG_pms)):
                    if(NH_pms[y][x]):
                        for a in range(len(NG_pms)):
                            if(D[a] and NH_pms[a][x] and Y[a]==0):
                                print(NH_pms[y])
                                print(NH_pms[a])
                                Y[a] = 1
                                Q[a] = 1
                                change = 1

    A = (np.zeros(len(NG_pms))).tolist()
    for x in range(len(Q)):
        if(D[x] and Q[x]==0):
            A[x] = 1

    #select the nodes in D and Y
    for f in range(len(D)):
        if(D[f] or Y[f]):
            id = outputStore[f][1]
            draw.itemconfig(outputStore[f][0],fill="yellow")
    #create the output message
    msg = "Inputs:"
    for x in range(len(D)):
        if(D[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nOutputs:"
    for x in range(len(Y)):
        if(Y[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nA:"
    for x in range(len(A)):
        if(A[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nQ:"
    for x in range(len(Q)):
        if(Q[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    popupmsg(msg)

def FIC_call(master,draw):
    #FIC
    NG_fic, NR_fic, NH_fic, Unknownnodes_pms = toAdjacencyMatrix(draw,master)
    D, Y, A, Blocking, condition = FIC(master,draw,NG_fic, NR_fic, NH_fic)
    if(condition):
        #select the nodes in D and Y
        for f in range(len(D)):
            if(D[f] or Y[f]):
                id = outputStore[f][1]
                draw.itemconfig(outputStore[f][0],fill="yellow")
            if(Blocking[f]):
                id = outputStore[f][1]
                draw.itemconfig(outputStore[f][0],fill="orange")
        #create the output message
        msg = "Inputs:"
        for x in range(len(D)):
            if(D[x]):
                msg = msg+" w"+str(x+1)+","
        msg = msg[:-1]
        msg = msg+"\nOutputs:"
        for x in range(len(Y)):
            if(Y[x]):
                msg = msg+" w"+str(x+1)+","
        msg = msg[:-1]
        msg = msg+"\nA:"
        for x in range(len(A)):
            if(A[x]):
                msg = msg+" w"+str(x+1)+","
        msg = msg[:-1]
        msg = msg+"\nBlocking:"
        for x in range(len(Blocking)):
            if(Blocking[x]):
                msg = msg+" w"+str(x+1)+","
        msg = msg[:-1]
        popupmsg(msg)


def FIC(master,draw,NG_fic, NR_fic, NH_fic):
    global outputStore
    global outputNumber
    global unknownNodenumber
    global NG_pms
    global NR_pms
    global NH_pms
    global storeNG
    global storeNH
    global storeNR
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    #look for the button
    NG_pms = copy.deepcopy(NG_fic)
    NH_pms = copy.deepcopy(NH_fic)
    NR_pms = copy.deepcopy(NR_fic)
    i = 0
    j = 0
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a
    if(i==j==0):
        msg = "No target module selected"
        popupmsg(msg)
        return 0,0,0,0,False
    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the A and B sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            D[x]=1;
    change = 1
    while(change):
        change = 0
        #looking for new outputs
        for u in range(len(Y)):
            if(Y[u]):
                for x in range(len(Y)):
                    if(NH_pms[u][x]):
                        for y in range(len(Y)):
                            if(NH_pms[y][x]):
                                if(Y[y]==0 and D[y]):        #Checking if it is a new output
                                    change = 1
                                    Y[y]=1
                                    print(NG_pms[y])
                                    for a in range(len(NG_pms)):
                                        if(NG_pms[y][a]):
                                            D[a]=1;
                                            print(a)
    D_indirect, Y_indirect = PMS(draw,master)
    A = (np.zeros(len(NG_pms))).tolist()
    for x in range(len(A)):
        if(D[x] and Y[x]==0):
            A[x]=1
    Blocking_possible = (np.zeros(len(D))).tolist()
    for x in range(len(D)):
        if(D_indirect[x] and D[x]==0):
            Blocking_possible[x]=1
    #condition 1: connection from Y
    for x in range(len(Blocking_possible)):
        if(Blocking_possible[x]):
            for y in range(len(Y)):
                if(Y[y] and NG_pms[x][y]):
                    Blocking_possible[x]=0
    #condition 2: connection through e with A
    for x in range(len(Blocking_possible)):
        if(Blocking_possible[x]):
            for y in range(len(A)):
                if(NH_pms[x][y]):
                    for a in range(len(A)):
                        if(NH_pms[a][y] and A[a]):
                            Blocking_possible[x]=0
    Blocking = Blocking_possible
    for x in range(len(Blocking_possible)):
        if(Blocking[x]):
            D[x]= 1
    return D, Y, A, Blocking, True

def PMS_call(master,draw):
    D,Y = PMS(master,draw)
    #create the output message
    msg = "Inputs:"
    for x in range(len(D)):
        if(D[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    msg = msg+"\nOutputs:"
    for x in range(len(Y)):
        if(Y[x]):
            msg = msg+" w"+str(x+1)+","
    msg = msg[:-1]
    popupmsg(msg)

def PMS(master, draw):
    global outputStore
    global outputNumber
    global unknownNodenumber
    global NG_pms
    global NR_pms
    global NH_pms
    global storeNG
    global storeNH
    global storeNR
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    #look for the button
    for x in range(number_of_nodes):
        if(btnStore[x]!=0):
            if(btnStore[x][1].pms==1):
                for y in range(lineNumber):
                    if(lineStore[y][3]==btnStore[x][1]):
                        for a in range(outputNumber):
                            if(lineStore[y][2]==outputStore[a][1]):
                                j = a
                            if(lineStore[y][1]==outputStore[a][1]):
                                i = a


    D = (np.zeros(len(NG_pms))).tolist()
    Y = (np.zeros(len(NG_pms))).tolist()
    #fill the D and Y sets with the initial nodes
    D[i] = 1
    Y[j] = 1
    for x in range(len(NG_pms)):
        if(NG_pms[j][x]):
            D[x]=1;
    change = 1
    while(change):
        print("D:")
        print(D)
        print("Y:")
        print(Y)
        change = 0
        Unknownnodes = []
        for x in range(len(D)):
            if(D[x] or Y[x]):
                Unknownnodes.append(0)
            else:
                Unknownnodes.append(1)
                unknownNodenumber +=1
        NG = copy.deepcopy(NG_pms)
        NH = copy.deepcopy(NH_pms)
        NR = copy.deepcopy(NR_pms)
        if(unknownNodenumber>0):
            G = []
            B = []
            R = []
            G, B, R = Immersion(NG,NR,NH,Unknownnodes,draw,master)
        else:
            G = NG
            B = NH
            R = NR
        #looking for new outputs
        for u in range(len(Y)):
            if(Y[u]):
                for x in range(len(B)):
                    if(B[u][x]):
                        for y in range(len(B)):
                            if(B[y][x]):
                                print(y)
                                if(Y[y]==0 and D[y]):        #Checking if it is a new output
                                    change = 1
                                    Y[y]=1
                                    for a in range(len(NG_pms)):
                                        if(NG_pms[y][a]):
                                            D[a]=1;
    return D,Y

#pops open a window to display a specific message
def popupmsg(msg):
    popup = Tk()
    popup.wm_title("!")
    label = Label(popup, text=msg)
    label.pack(side="top", fill="x", pady=10)
    B1 = Button(popup, text="Okay", command = popup.destroy)
    B1.pack()
    popup.mainloop()

#peforms the correct pms based on what the user has selected
def PMS_option(draw,master):
    type_pms = layoutMethod1.get()
    if(type_pms == "USC"):
        USC(master,draw)
    if(type_pms == "MIC"):
        MIC(master,draw)
    if(type_pms == "FIC"):
        FIC_call(master,draw)

"""
below are the functions for

-------------------------------------------------------- Immersion --------------------------------------------------------
"""

def Unknownnodesbottom(NG, NR, NH, Unknownnodes):
    global unknownNodenumber
    correct_nodes = 0
    len_Unknownnodes = len(Unknownnodes)-1
    while(unknownNodenumber>correct_nodes):
        #Check if the bottom node is a unknown node
        if(Unknownnodes[len_Unknownnodes-correct_nodes]):
            correct_nodes += 1
        #If not, place the first unknown node at the bottom
        else:
            a = 0
            x = 0
            while(a==0):
                if(Unknownnodes[x]):
                    #Switch the nodes in NG matrix
                    row1 = copy.deepcopy(NG[x])
                    row2 = copy.deepcopy(NG[len_Unknownnodes-correct_nodes])
                    NG[x] = row2
                    NG[len_Unknownnodes-correct_nodes] = row1
                    column1 = []
                    column2 = []
                    for y in range(len(NG)):
                        column1.append(NG[y][x])
                        column2.append(NG[y][len_Unknownnodes-correct_nodes])
                    for y in range(len(NG)):
                        NG[y][x] = column2[y]
                        NG[y][len_Unknownnodes-correct_nodes] = column1[y]
                    #Switch the nodes in NH matrix
                    rowNH1 = copy.deepcopy(NH[x])
                    rowNH2 = copy.deepcopy(NH[len_Unknownnodes-correct_nodes])
                    NH[x] = rowNH2
                    NH[len_Unknownnodes-correct_nodes] = rowNH1
                    #Switch the nodes in NR matrix
                    rowNR1 = copy.deepcopy(NR[x])
                    rowNR2 = copy.deepcopy(NR[len_Unknownnodes-correct_nodes])
                    NR[x] = rowNR2
                    NR[len_Unknownnodes-correct_nodes] = rowNR1
                    #Switch the nodes in Unknownnodes list
                    Unknownnodes[x] = 0
                    Unknownnodes[len_Unknownnodes-correct_nodes] = 1
                    a = 1
                x +=1
    #change NG to a list if it is not already
    if(False==(isinstance(NG, list))):
        NG = NG.tolist()
    #change NH to an array if it is not already
    if(False==(isinstance(NH,np.ndarray))):
        NH = np.array(NH)
    if(False==(isinstance(NR, list))):
        NR = NR.tolist()
    return NG, NR, NH, Unknownnodes

def Immersion_call(master,draw):
    global storeNG
    global storeNH
    global storeNR
    NG, NR, NH, Unknownnodes= toAdjacencyMatrix(draw,master)
    G, B, R = Immersion(NG,NR,NH,Unknownnodes,draw,master)
    clearWindow(draw,0)
    storeNG = G
    storeNH = B
    storeNR = R
    plotMatrix(draw,master,1)

#this function performs Immersion
def Immersion(NG,NR,NH,Unknownnodes,draw,master):
    global NG_pms
    global NR_pms
    global NH_pms
    global outputNumber
    global outputStore
    global lineStore
    global lineNumber
    global unknownNodenumber
    global storeNG
    global storeNH
    global storeNR
    Unknownnodes_start = copy.deepcopy(Unknownnodes)
    Unknownnodes_start_1 = copy.deepcopy(Unknownnodes)
    NG, NR, NH, Unknownnodes= Unknownnodesbottom(NG, NR, NH, Unknownnodes)
    test = np.array(NG)
    test1 = np.array(NH)
    test2 = np.array(NR)
    print("NG with unknownnodes at the bottom:")
    print(test)
    print("NH with unknownnodes at the bottom:")
    print(test1)
    print("NR with unknownnodes at the bottom:")
    print(test2)
    iteration = 0
    G = copy.deepcopy(NG)
    while(iteration<unknownNodenumber):
        for x in range(len(G)):
            for y in range(len(G)):
                if(Unknownnodes[y] and NG[x][y]):
                    for r in range(len(G)):
                        if(NG[y][r]):
                            G[x][r] = 1
        iteration += 1
    len_G = len(G)
    for x in range(unknownNodenumber):
        for y in range(len(G)):
            G[y][len_G-x-1] = 0
            G[len_G-x-1][y] = 0
    #switching to the right position

    B = NH
    #Find the nodes to which the unknown nodes used to point (before Immersion)
    itteration = 0
    while(itteration<unknownNodenumber):
        for x in range(len(B)):
            if(Unknownnodes[x]):          #unknown node is found
                for y in range(len(B[0])):
                    if(NG[y][x]):       #nodes to which the unknown node point
                        for a in range(len(B[0])):
                            if(NH[x][a]):
                                NH[y][a] = 1
        itteration += 1

    R = NR
    #Same computation for NR as for NH
    itteration = 0
    while(itteration<unknownNodenumber):
        for x in range(len(Unknownnodes)):
            if(Unknownnodes[x]):          #unknown node is found
                for y in range(len(NG)):
                    if(NG[y][x]):       #nodes to which the unknown node point
                        for a in range(len(R[0])):
                            if(NR[x][a]):
                                R[y][a] = 1
        itteration += 1
    switched_nodes = 0
    len_Unknownnodes = len(Unknownnodes_start)-1
    while(unknownNodenumber>switched_nodes):
        #Check if the bottom node is a unknown node
        if(Unknownnodes_start[len_Unknownnodes-switched_nodes]):
            switched_nodes += 1
        #If not, place the first unknown node at the bottom
        else:
            a = 0
            x = 0
            while(a==0):
                if(Unknownnodes_start[x]):
                    #Switch the nodes in NG matrix
                    row1 = copy.deepcopy(G[x])
                    row2 = copy.deepcopy(G[len_Unknownnodes-switched_nodes])
                    G[x] = row2
                    G[len_Unknownnodes-switched_nodes] = row1
                    column1 = []
                    column2 = []
                    for y in range(len(G)):
                        column1.append(G[y][x])
                        column2.append(G[y][len_Unknownnodes-switched_nodes])
                    for y in range(len(G)):
                        G[y][x] = column2[y]
                        G[y][len_Unknownnodes-switched_nodes] = column1[y]
                    #Switch the NH back
                    rowNH1 = copy.deepcopy(B[x])
                    rowNH2 = copy.deepcopy(B[len_Unknownnodes-switched_nodes])
                    B[x] = rowNH2
                    B[len_Unknownnodes-switched_nodes] = rowNH1
                    #Switch the NR same as NH
                    rowNR1 = copy.deepcopy(R[x])
                    rowNR2 = copy.deepcopy(R[len_Unknownnodes-switched_nodes])
                    R[x] = rowNR2
                    R[len_Unknownnodes-switched_nodes] = rowNR1
                    #Switch the nodes in Unknownnodes list
                    Unknownnodes_start[x] = 0
                    Unknownnodes_start[len_Unknownnodes-switched_nodes] = 1
                    a = 1
                x +=1
    print("New NG after Immersion is:")
    print(G)
    #Set the new NH as the old NH
    r = 0
    B = B.tolist()
    for x in range (len(Unknownnodes_start_1)):
        if(Unknownnodes_start_1[x]):
            new = []
            for y in range(len(B[0])):
                new.append(0)
            B[x]=new
            R[x]=new
    #        r = r + 1
            Unknownnodes_start_1[x] = 0
            unknownNodenumber -= 1
    print("New NH after Immersion is:")
    B = np.array(B)
    print(B)
    print("New NR after Immersion is:")
    R = np.array(R)
    print(R)
    print("End of Immersion")
    return G, B, R

"""
below are the remaining

-------------------------------------------------------- Remaining --------------------------------------------------------
"""

#sets line between nodes to be dashed which is very usefull in the noiseview
def Dashed_line(draw,master):
    global lineshow
    global lineStore
    global lineNumber
    global overlay

    #only in the noise view dashed lines are existing
    if(overlay):
        if(lineshow):
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "white")
            lineshow = 0
        else:
            for x in range(lineNumber):
                if(lineStore[x][3]==1):
                    draw.itemconfig(lineStore[x][0],fill = "black")
            lineshow = 1

#deletes all entries on the canvas and sets all variables back to 0
def clearWindow(canvas,canReset):
    #remove everythin and set all global to 0
    global number_of_nodes
    global outputNumber
    global btnStore
    global outputStore
    global noiseStore
    global noiseNumber
    global excitationNumber
    global excitationStore
    global currentAmountOutputSelected
    global lineNumber
    global lineStore
    global noiseNodeStore
    global noiseNodeNumber
    global storeNG
    global storeNR
    global storeNH
    global overlay
    global unit
    global currentView
    global newPathColor
    global currentGroup
    global treeStore
    global butTestStore
    global butTestNumber
    canvas.delete("all")
    number_of_nodes = 0
    outputNumber = 0
    btnStore = []
    outputStore = []
    noiseStore = []
    noiseNumber = 0
    excitationStore = []
    excitationNumber = 0
    currentAmountOutputSelected = 1
    linestore = 0
    lineNumber = 0
    noiseNodeNumber = 0
    noiseNodeStore = []
    storeNG = storeNR = storeNH = []
    overlay = 0
    newPathColor = 0
    currentview = 0
    butTestStore = []
    butTestNumber = 0
    unknownNodenumber = 0
    currentGroup = 1
    treeStore = []
    if(canReset==1):
        excitationNumber = 0
        if(unit.currentZoom > 1):
            unit.canvas.scale('all', unit.currentZoom, unit.currentZoom, 1, 1)
        if(unit.currentZoom < 1):
            unit.canvas.scale('all', 1, 1, unit.currentZoom, unit.currentZoom)
        unit.currentZoom = 1



#this functions searches 2 selected nodes and then gives them to connectOutputs to be well connected with each other
def connectCall(draw,master):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    node1 = 0
    node2 = 0

    #serach first for selected outputs
    for x in range(outputNumber):
        if(outputStore[x][1].stat==2):
            if(outputStore[x][1]!=node1 and node1==0):
                node1 = outputStore[x]
            elif(node2!=outputStore[x][1]):
                node2 = outputStore[x]

    if(overlay==1):
        node2 = 0
        for x in range(noiseNodeNumber):
            if(noiseNodeStore[x][1].stat==2):
                if(noiseNodeStore[x][1]!=node2 and node2==0):
                    node2 = noiseNodeStore[x]
                    #print("found noise at: ",node2," linking to ",node1)


    #check if the node is not the same or not 0.
    if((node1==node2) or (node1 == 0 or node2 == 0)):
        print("error occured with node selection")

    else:
        #check for which order they are selected so that the last selected is the target module and the first the origin.
        if(node1[1].order > node2[1].order):
            connectOutputs(node2,node1,draw,master,1)
        else:
            connectOutputs(node1,node2,draw,master,1)
        xObj, yObj = trueCoordinates(draw,node1)
        circleScan(draw,master,xObj,yObj)
        if(overlay==0):
            xObj, yObj = trueCoordinates(draw,node2)
            circleScan(draw,master,xObj,yObj)
        else:
            selectNoiseNode(node2[1])

#connectOutputs is given 2 nodes and a variable placeBtn which determines the to only create a line or also a button. Afterwards it creates a line connetion between the 2 nodes
def connectOutputs(node1,node2,draw,master,placeBtn):
    global number_of_nodes
    global btnStore
    global lineStore
    global lineNumber
    temp = 0
    node3 = 0


    for x in range(lineNumber):
        if(lineStore[x]!=0):
            if(node1[1]==lineStore[x][1] and node2[1]==lineStore[x][2]):
                temp = 1
    if(node1==node2):
        temp = 1
    #make sure that the connection is not made already or the nodes are the same
    #else make the connection
    if(temp==0):
        node1[2],node1[3] = trueCoordinates(draw,node1)
        node2[2],node2[3] = trueCoordinates(draw,node2)
        x_middle = (node2[2] + node1[2])/2
        y_middle = (node1[3] + node2[3])/2

        #draw the curve
        #slope
        if((node2[2]-node1[2])!=0):
            theta = math.degrees(math.atan((node2[3]-node1[3])/(node2[2]-node1[2])))
        else:
            theta = 90;
        length_line = math.sqrt(math.pow(node2[2]-node1[2],2)+math.pow(node2[3]-node1[3],2))/2
        height_curve = length_line/3
        if(node1>node2):
            x_transfer = x_middle + math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle - math.sin(math.radians(90-theta))*height_curve
        else:
            x_transfer = x_middle - math.cos(math.radians(90-theta))*height_curve
            y_transfer = y_middle + math.sin(math.radians(90-theta))*height_curve
        #draw the transfer
        #set btn when needed.
        if(placeBtn):
            addNode(draw,(x_transfer+x_middle)/2,(y_transfer+y_middle)/2,master,node1,node2)
            for x in range(number_of_nodes):
                if(btnStore[x]!=0):
                    if(btnStore[x][2]==(x_transfer+x_middle)/2 and btnStore[x][3]==(y_transfer+y_middle)/2):
                        node3 = btnStore[x]
        else:
            #create a fake note
            node3 = [1,1]
        #end of draw the tranfer

        if(placeBtn):
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true")
        else:
            lineWidget = draw.create_line(node1[2], node1[3], x_transfer, y_transfer, node2[2], node2[3], smooth="true", width=0.01, dash=(5, 10))
        tempStore = [lineWidget, node1[1], node2[1], node3[1],"black","line"]
        lineStore.insert(lineNumber,tempStore)
        lineNumber = lineNumber+1


        #draw the arrow

        gamma = 45/2 #adjust the angle of the arrow
        length_arrow = 5*unit.currentZoom #adjust the lenght of the arrow

        sign_2 = 1
        if(node1[2]>node2[2]):
            sign_2 = -1

        if(node1>node2):
            x_arrow0 = (x_middle+node2[2])/2 + math.cos(math.radians(90-theta))*height_curve/5.4*2
            y_arrow0 = (y_middle+node2[3])/2 - math.sin(math.radians(90-theta))*height_curve/5.4*2
            epsilon = 180-gamma-theta-90-6*sign_2
        else:
            x_arrow0 = (x_middle+node2[2])/2 - math.cos(math.radians(90-theta))*height_curve/5.4*2
            y_arrow0 = (y_middle+node2[3])/2 + math.sin(math.radians(90-theta))*height_curve/5.4*2
            epsilon = 180-gamma-theta-90+6*sign_2

        x_arrow1 = x_arrow0 - sign_2*math.sin(math.radians(epsilon))*length_arrow
        y_arrow1 = y_arrow0 - sign_2*math.cos(math.radians(epsilon))*length_arrow
        alpha = gamma+epsilon
        alpha_hypotenusa = sign_2*math.sin(math.radians(gamma))*length_arrow*2
        x_arrow2 = x_arrow1 - math.cos(math.radians(alpha))*alpha_hypotenusa
        y_arrow2 = y_arrow1 + math.sin(math.radians(alpha))*alpha_hypotenusa
        tempStore2 = [draw.create_line(x_arrow1, y_arrow1, x_arrow0,y_arrow0, x_arrow2, y_arrow2),node1[1],node2[1],node3[1],"black","arrow"]
        lineStore.insert(lineNumber,tempStore2)
        lineNumber = lineNumber+1

        draw.tag_raise("nodes")
        draw.tag_raise("rect")
        draw.tag_raise("wNotation")

def define_circle(p1, p2, p3):
    """
    Returns the center and radius of the circle passing the given 3 points.
    In case the 3 points form a line, returns (None, infinity).
    """
    temp = p2[0] * p2[0] + p2[1] * p2[1]
    bc = (p1[0] * p1[0] + p1[1] * p1[1] - temp) / 2
    cd = (temp - p3[0] * p3[0] - p3[1] * p3[1]) / 2
    det = (p1[0] - p2[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p2[1])

    if abs(det) < 1.0e-6:
        return (None, np.inf)

    # Center of circle
    cx = (bc*(p2[1] - p3[1]) - cd*(p1[1] - p2[1])) / det
    cy = ((p1[0] - p2[0]) * cd - (p2[0] - p3[0]) * bc) / det

    radius = np.sqrt((cx - p1[0])**2 + (cy - p1[1])**2)
    return (cx, cy, radius)

#set the clickOperation button to a specific variable so that it can peform that operation on the next click
def addWidget(input):
    #set the clickOperation variable
    global clickOperation
    clickOperation = input

#This function is triggered everytime one clicks on the canvas. it will check if you selected anything and then peform the necessary operations
def clickEvent(event):
    #on button press perform an action based on click clickOperation
    global clickOperation
    x = draw.canvasx(event.x)
    y = draw.canvasy(event.y)
    if(clickOperation==0 and currentView == 1):
        circleScan(draw,master,x,y)
    if(clickOperation==1):
        addNode(event.widget, x, y, master)
        clickOperation=0

    if(clickOperation==2):
        addOutput(event.widget, x, y, master)
        print("node added at: ",x,",",y)
        clickOperation=0

    if(clickOperation==3):
        addNoiseNode(draw, x, y, master)
        clickOperation=0

#this function does all the transformations to check if you mouse click was in a node
def circleScan(draw,master,x,y):
    global currentAmountOutputSelected
    global outputStore
    #this function scans the mouse click and tries to find if it is within a circle
    #print("scanning for button at: ",x,",",y)
    #draw.create_circle(x,y,10,fill="green")
    #circle through all unknown nodes to check within their radius
    for f in range(outputNumber):
        if(outputStore[f]!=0):
            #the zoom function and drag messes with the old coordintes with trueCoordinates you obtain the in that view correct coordinates
            xObj, yObj = trueCoordinates(draw,outputStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < nodeSize*unit.currentZoom):
                selectOutput(f,draw)

    for f in range(noiseNodeNumber):
        if(noiseNodeStore[f]!=0):
            xObj, yObj = trueCoordinates(draw,noiseNodeStore[f])
            xN = math.pow((x-xObj),2)
            yN = math.pow((y-yObj),2)

            dis = math.sqrt(xN + yN)
            #if within radius (unit.currentZoom is correct for the zoom in)
            if (dis < nodeSize*unit.currentZoom):
                id = noiseNodeStore[f]
                selectNoiseNode(id)

    for f in range(number_of_nodes):
        if(btnStore[f]!=0):
            if(btnStore[f]!=0):
                xObj, yObj = trueCoordinates(draw,btnStore[f])
                yObj -= nodeSize*unit.currentZoom*0.4
                height = nodeSize*unit.currentZoom*0.7
                width = nodeSize*unit.currentZoom
                #print("searching for x: ",xObj," y: ",yObj)
                #print(x,",",y)
                if(xObj-width<x and x<xObj+width):
                    if(yObj-height<y and y<yObj+height):
                        if(btnStore[f][1].stat==1):
                            draw.itemconfig(btnStore[f][0], fill="yellow")
                            btnStore[f][1].stat=2
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="red")

                        else:
                            if(btnStore[f][1].known == 1):
                                draw.itemconfig(btnStore[f][0], fill="green")
                            elif(btnStore[f][1].pms == 1):
                                draw.itemconfig(btnStore[f][0], fill="blue")
                            else:
                                draw.itemconfig(btnStore[f][0], fill="cyan")
                            btnStore[f][1].stat=1
                            for a in range(lineNumber):
                                if(lineStore[a]!=0):
                                    if lineStore[a][3]==btnStore[f][1]:
                                        draw.itemconfig(lineStore[a][0], fill="black")
    #reload the right view if a node is selected
    selectedNode = 0
    if(currentAmountOutputSelected == 2):
        for x in range(outputNumber):
            if(outputStore[x]!=0):
                if(outputStore[x][1].stat==2 or outputStore[x][1].stat==4):
                    selectedNode=outputStore[x][1]
                    print("found node and giving it to reloadCall")
    reloadCall(subMenu,reload,currentAmountOutputSelected,selectedNode)



#the zoom and pan function changes the x y coordinates relative to what was saved. this corrects those
def trueCoordinates(draw,node):
    #draw.coords obtains the current coordinates based on the widget id. + the radius multiply by zoom to shift the left corner of the widget to the center.
    xObj = draw.coords(node[0])[0]+nodeSize*unit.currentZoom
    yObj = draw.coords(node[0])[1]+nodeSize*unit.currentZoom
    #xObj = draw.canvasx(node[2])
    #yObj = draw.canvasy(node[3])
    return xObj, yObj

"""
Below you will find the basic setup of the grid

-------------------------------------------------------- Grid interface setup and initialization --------------------------------------------------------
"""

# creating Tk window which will hold all content
master = Tk()
master.configure(background="gray")
master.title("Delivery Demo")
#set initial size
master.geometry("1000x1000")

#create a grid which can reize with the resizing of the box
Grid.rowconfigure(master, 0, weight=1)
Grid.columnconfigure(master, 0, weight=1)
masterFrame = Frame(master)
masterFrame.grid(row=0, column=0, sticky=N+S+E+W)
Grid.rowconfigure(masterFrame, 0, weight=1)
Grid.rowconfigure(masterFrame, 1, weight=100)
Grid.columnconfigure(masterFrame, 0, weight=100)
Grid.columnconfigure(masterFrame, 1, weight=1)

#seperating the menu in different frames which will hold all the components so that it is easier to use .grid for button placement
#main menu is for the upper buttons, canvas is for draw, subMenu is for the component selection
mainMenu = Frame(masterFrame, bg="gray")
canvas = Frame(masterFrame, bg="white")
subMenu = Frame(masterFrame, bg="gray")

#set each frame in the grid
mainMenu.grid(row=0,sticky=N+S+E+W)
canvas.grid(row=1, sticky=N+S+E+W)
subMenu.grid(row=0, column=1, rowspan=2, sticky=N+S+E+W)

#create a canvas called draw in the canvas frame
draw = Canvas(canvas, bg="white")
draw.pack(fill="both", expand=True)

#defines options that need to be shown on screen
layout = [
"circular",
"kamada_kawai",
"spring",
"spectral",
"spiral"
]
layout1 = [
#"standard",
"MIC",
"FIC",
"USC"
]

views = [
"Noise view",
"Abstract view",
"Detail view"
]

layoutMethod = StringVar(master)
layoutMethod.set(layout[1])
layoutMethod1 = StringVar(master)
layoutMethod1.set(layout1[0])
viewMethod = StringVar(master)
viewMethod.set(views[1])
viewMethod.trace("w",viewCall)

#bind functions to events
initMainMenu(mainMenu, draw)
reload = initSubMenu(subMenu)

#set the draw canvas with the scroll and pan option
unit = Zoom_Advanced(draw)
#bind button Release to the clickevent
unit.canvas.bind("<ButtonRelease-1>",clickEvent)

#start the loop in which it will watch for events
mainloop()
